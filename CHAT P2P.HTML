<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat P2P com Contatos</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    #root {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .peer-id-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .user-info-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 10px;
      background: #f0f8ff;
      border-radius: 5px;
    }
    .user-name-form {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .peer-id-input {
      flex: 1;
      margin-right: 10px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .message {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    .message.you {
      background-color: #e3f2fd;
      margin-left: 20%;
    }
    .message.other {
      background-color: #f1f1f1;
      margin-right: 20%;
    }
    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .file-link {
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .progress-container {
      margin-top: 5px;
    }
    .progress-bar {
      height: 5px;
      background: #ddd;
      border-radius: 3px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #4CAF50;
      width: 0%;
      transition: width 0.3s ease;
    }
    .connected-peers {
      margin-top: 10px;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .peer-item {
      margin: 5px 0;
      padding: 5px;
      background: #e3f2fd;
      border-radius: 3px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .voice-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .voice-button.recording {
      background: #ff0000;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .button-icon {
      color: white;
      font-size: 16px;
    }
    .audio-player {
      margin-top: 5px;
      width: 100%;
    }
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .contact-form-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .contact-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .contacts-list {
      max-height: 300px;
      overflow-y: auto;
      border-right: 4px solid #4CAF50;
      padding-right: 10px;
    }
    .username {
      font-weight: bold;
      color: #1976d2;
    }
    .call-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 10px;
    }
    .call-button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .video-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
    }
    .video-player {
      width: 100%;
      max-width: 400px;
      border-radius: 8px;
      border: 1px solid #ddd;
    }
    .remote-video {
      background: #000;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Error Boundary to catch runtime errors
    class ErrorBoundary extends React.Component {
      state = { error: null };

      static getDerivedStateFromError(error) {
        return { error };
      }

      render() {
        if (this.state.error) {
          return (
            <div style={{ padding: '20px', color: 'red' }}>
              <h1>Erro na aplica√ß√£o</h1>
              <p>{this.state.error.message}</p>
              <p>Verifique o console do navegador para mais detalhes.</p>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const PEER_ID_STORAGE_KEY = 'p2pChatClientId';

    const usePersistentId = () => {
      const [peerId, setPeerId] = useState('');

      const generateId = () => {
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        const buffer = new Uint8Array(6);
        crypto.getRandomValues(buffer);
        return Array.from(buffer)
          .map(b => chars[b % chars.length])
          .join('');
      };

      useEffect(() => {
        const loadOrGenerateId = () => {
          const savedId = localStorage.getItem(PEER_ID_STORAGE_KEY);
          if (savedId) {
            setPeerId(savedId);
          } else {
            const newId = generateId();
            localStorage.setItem(PEER_ID_STORAGE_KEY, newId);
            setPeerId(newId);
          }
        };
        loadOrGenerateId();
      }, []);

      return [peerId, setPeerId];
    };

    const VoiceRecorder = ({ onRecordingComplete, disabled }) => {
      const [isRecording, setIsRecording] = useState(false);
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);

      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorderRef.current = new MediaRecorder(stream);
          
          mediaRecorderRef.current.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunksRef.current.push(event.data);
            }
          };
          
          mediaRecorderRef.current.onstop = () => {
            if (audioChunksRef.current.length === 0) {
              console.error("No audio data collected");
              return;
            }
            
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            onRecordingComplete(audioBlob);
            audioChunksRef.current = [];
            
            stream.getTracks().forEach(track => track.stop());
          };
          
          audioChunksRef.current = [];
          mediaRecorderRef.current.start(200);
          setIsRecording(true);
        } catch (err) {
          alert('Erro ao acessar o microfone: ' + err);
          console.error(err);
        }
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          try {
            mediaRecorderRef.current.stop();
          } catch (err) {
            console.error("Error stopping media recorder:", err);
          }
          setIsRecording(false);
        }
      };

      const toggleRecording = () => {
        if (isRecording) {
          stopRecording();
        } else {
          startRecording();
        }
      };

      return (
        <button 
          className={`voice-button ${isRecording ? 'recording' : ''}`}
          onClick={toggleRecording}
          disabled={disabled}
          title="Gravar √°udio"
        >
          <i className="fas fa-microphone button-icon"></i>
        </button>
      );
    };

    const ContactsScreen = ({ contacts, setContacts, onBack, onSelectContact }) => {
      const [newName, setNewName] = useState('');
      const [newPeerId, setNewPeerId] = useState('');
      const [nameError, setNameError] = useState('');
      const [idError, setIdError] = useState('');

      const validateForm = () => {
        let isValid = true;
        
        if (!newName.trim()) {
          setNameError('Nome √© obrigat√≥rio');
          isValid = false;
        } else {
          setNameError('');
        }
        
        if (!newPeerId.trim()) {
          setIdError('ID √© obrigat√≥rio');
          isValid = false;
        } else {
          setIdError('');
        }
        
        return isValid;
      };

      const handleAddContact = (e) => {
        e.preventDefault();
        
        if (validateForm()) {
          const newContact = { name: newName, peerId: newPeerId };
          setContacts(prev => {
            const updated = [...prev, newContact];
            localStorage.setItem('p2pContacts', JSON.stringify(updated));
            return updated;
          });
          setNewName('');
          setNewPeerId('');
        }
      };

      const handleRemoveContact = (peerId, e) => {
        e.stopPropagation();
        setContacts(prev => {
          const updated = prev.filter(c => c.peerId !== peerId);
          localStorage.setItem('p2pContacts', JSON.stringify(updated));
          return updated;
        });
      };

      return (
        <div>
          <button onClick={onBack} style={{ marginBottom: '20px' }}>
            ‚Üê Voltar
          </button>
          <h2>Lista de Contatos</h2>
          
          <form className="contact-form" onSubmit={handleAddContact}>
            <div className="contact-form-row">
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="Nome do contato"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  style={{ borderColor: nameError ? 'red' : '#ddd' }}
                />
                {nameError && <span style={{ color: 'red', fontSize: '12px' }}>{nameError}</span>}
              </div>
              
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="ID do contato"
                  value={newPeerId}
                  onChange={(e) => setNewPeerId(e.target.value)}
                  style={{ borderColor: idError ? 'red' : '#ddd' }}
                />
                {idError && <span style={{ color: 'red', fontSize: '12px' }}>{idError}</span>}
              </div>
              
              <button type="submit">Adicionar</button>
            </div>
          </form>

          <div className="connected-peers contacts-list">
            {contacts.length === 0 ? (
              <p>Nenhum contato adicionado ainda.</p>
            ) : (
              contacts.map((contact, i) => (
                <div 
                  key={i} 
                  className="peer-item"
                  onClick={() => onSelectContact(contact.peerId)}
                >
                  <span style={{ flex: 1 }}>
                    {contact.name} - {contact.peerId}
                  </span>
                  <button 
                    onClick={(e) => handleRemoveContact(contact.peerId, e)}
                    style={{ marginLeft: '10px' }}
                  >
                    üóëÔ∏è
                  </button>
                </div>
              ))
            )}
          </div>
        </div>
      );
    };

    const App = () => {
      const [peerId, setPeerId] = usePersistentId();
      const [userName, setUserName] = useState(() => {
        return localStorage.getItem('p2pUserName') || '';
      });
      const [editingName, setEditingName] = useState(!localStorage.getItem('p2pUserName'));
      const [connections, setConnections] = useState([]);
      const [messages, setMessages] = useState([]);
      const [newMessage, setNewMessage] = useState('');
      const [showContacts, setShowContacts] = useState(false);
      const [contacts, setContacts] = useState(() => {
        const saved = localStorage.getItem('p2pContacts');
        return saved ? JSON.parse(saved) : [];
      });
      const [activeCalls, setActiveCalls] = useState([]); // [{ peerId, call, localStream }, ...]
      const [remoteStreams, setRemoteStreams] = useState([]); // [{ peerId, stream }, ...]

      const peerInstance = useRef(null);
      const fileInputRef = useRef(null);
      const pendingFiles = useRef({});
      const messagesEndRef = useRef(null);
      const videoRefs = useRef({}); // To store refs for each remote video element
      const CHUNK_SIZE = 16 * 1024;

      const generateNewId = () => {
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        const buffer = new Uint8Array(6);
        crypto.getRandomValues(buffer);
        const newId = Array.from(buffer)
          .map(b => chars[b % chars.length])
          .join('');
        localStorage.setItem(PEER_ID_STORAGE_KEY, newId);
        return newId;
      };

      const getContactName = (peerId) => {
        const contact = contacts.find(c => c.peerId === peerId);
        return contact ? contact.name : peerId;
      };

      const saveUserName = () => {
        if (userName.trim()) {
          localStorage.setItem('p2pUserName', userName);
          setEditingName(false);
        }
      };

      useEffect(() => {
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
      }, [messages]);

      useEffect(() => {
        // Assign video refs to streams
        remoteStreams.forEach(({ peerId, stream }) => {
          const videoElement = videoRefs.current[peerId];
          if (videoElement && videoElement.srcObject !== stream) {
            videoElement.srcObject = stream;
          }
        });
      }, [remoteStreams]);

      useEffect(() => {
        if (!peerId) return;

        const createPeer = () => {
          const peer = new Peer(peerId, {
            host: '0.peerjs.com',
            port: 443,
            secure: true,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
              ]
            },
            debug: 3
          });

          peer.on('open', (id) => {
            console.log("Connected to PeerJS with ID:", id);
          });

          peer.on('call', (call) => {
            console.log('Recebendo chamada de:', call.peer);

            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
              .then((stream) => {
                call.answer(stream);
                setActiveCalls(prev => [...prev, {
                  peerId: call.peer,
                  call,
                  localStream: stream
                }]);

                call.on('stream', (remoteStream) => {
                  console.log(`Recebido stream de ${call.peer}`);
                  setRemoteStreams(prev => {
                    const exists = prev.some(s => s.peerId === call.peer);
                    if (exists) {
                      return prev.map(s => s.peerId === call.peer ? { peerId: call.peer, stream: remoteStream } : s);
                    }
                    return [...prev, { peerId: call.peer, stream: remoteStream }];
                  });
                });

                call.on('close', () => {
                  endCall(call.peer);
                });

                call.on('error', (err) => {
                  console.error('Erro na chamada:', err);
                  alert('Erro na chamada: ' + err.message);
                  endCall(call.peer);
                });
              })
              .catch((err) => {
                console.error('Erro ao responder chamada:', err);
                alert('Erro ao acessar a c√¢mera/microfone: ' + err.message);
                call.close();
              });
          });

          peer.on('error', (err) => {
            console.error("PeerJS error:", err);
            if (err.type === 'unavailable-id') {
              console.log("ID unavailable, generating new ID...");
              const newId = generateNewId();
              setPeerId(newId);
              peer.destroy();
            } else {
              alert(`Erro de conex√£o: ${err.type}`);
            }
          });

          peer.on('connection', (conn) => {
            console.log("Incoming connection from:", conn.peer);
            
            conn.on('open', () => {
              console.log("Connection opened with:", conn.peer);
              setConnections(prev => {
                if (!prev.some(c => c.peer === conn.peer)) {
                  return [...prev, conn];
                }
                return prev;
              });
            });

            conn.on('data', (data) => {
              console.log("Received data from:", conn.peer, data.type);
              handleIncomingData(data, conn.peer);
            });

            conn.on('close', () => {
              console.log("Connection closed with:", conn.peer);
              setConnections(prev => prev.filter(c => c.peer !== conn.peer));
            });

            conn.on('error', (err) => {
              console.error("Connection error with:", conn.peer, err);
            });
          });

          peerInstance.current = peer;
        };

        createPeer();

        return () => {
          console.log("Destroying peer connection");
          if (peerInstance.current) {
            peerInstance.current.destroy();
          }
          activeCalls.forEach(call => endCall(call.peerId));
        };
      }, [peerId]);

      const handleIncomingData = (data, peerId) => {
        console.log("Processing incoming data of type:", data.type);
        
        if (data.type === 'message') {
          setMessages(prev => [...prev, {
            text: data.text,
            sender: peerId,
            senderName: data.senderName || getContactName(peerId),
            time: new Date().toLocaleTimeString(),
            type: 'text'
          }]);
        } else if (data.type === 'file-start') {
          pendingFiles.current[data.fileId] = {
            fileName: data.fileName,
            chunks: new Uint8Array(data.fileSize),
            receivedBytes: 0,
            totalSize: data.fileSize
          };
          
          setMessages(prev => [...prev, {
            fileId: data.fileId,
            fileName: data.fileName,
            sender: peerId,
            senderName: data.senderName || getContactName(peerId),
            time: new Date().toLocaleTimeString(),
            type: 'file',
            receiving: true,
            progress: 0
          }]);
        } else if (data.type === 'file-chunk') {
          const fileData = pendingFiles.current[data.fileId];
          if (fileData) {
            const chunk = new Uint8Array(data.chunk);
            fileData.chunks.set(chunk, data.offset);
            fileData.receivedBytes += chunk.length;
            
            const progress = Math.floor((fileData.receivedBytes / fileData.totalSize) * 100);
            
            setMessages(prev => prev.map(msg => 
              msg.fileId === data.fileId ? { ...msg, progress } : msg
            ));

            if (fileData.receivedBytes === fileData.totalSize) {
              const blob = new Blob([fileData.chunks], { type: 'application/octet-stream' });
              const url = URL.createObjectURL(blob);
              
              setMessages(prev => prev.map(msg => 
                msg.fileId === data.fileId ? { 
                  ...msg, 
                  fileData: url,
                  receiving: false
                } : msg
              ));
              
              delete pendingFiles.current[data.fileId];
            }
          }
        } else if (data.type === 'audio-start') {
          console.log("Received audio-start:", data);
          pendingFiles.current[data.audioId] = {
            chunks: new Uint8Array(data.audioSize),
            receivedBytes: 0,
            totalSize: data.audioSize
          };
          
          setMessages(prev => [...prev, {
            audioId: data.audioId,
            sender: peerId,
            senderName: data.senderName || getContactName(peerId),
            time: new Date().toLocaleTimeString(),
            type: 'audio',
            receiving: true,
            progress: 0
          }]);
        } else if (data.type === 'audio-chunk') {
          const audioData = pendingFiles.current[data.audioId];
          if (audioData) {
            const chunk = new Uint8Array(data.chunk);
            audioData.chunks.set(chunk, data.offset);
            audioData.receivedBytes += chunk.length;
            
            const progress = Math.floor((audioData.receivedBytes / audioData.totalSize) * 100);
            
            setMessages(prev => prev.map(msg => 
              msg.audioId === data.audioId ? { ...msg, progress } : msg
            ));

            if (audioData.receivedBytes === audioData.totalSize) {
              const blob = new Blob([audioData.chunks], { type: 'audio/webm' });
              const url = URL.createObjectURL(blob);
              
              setMessages(prev => prev.map(msg => 
                msg.audioId === data.audioId ? { 
                  ...msg, 
                  audioData: url,
                  receiving: false
                } : msg
              ));
              
              delete pendingFiles.current[data.audioId];
            }
          }
        }
      };

      const connectToPeer = (peerIdToConnect) => {
        if (!peerIdToConnect || !peerInstance.current) {
          console.error("Cannot connect: missing peer ID or peer instance");
          return;
        }

        console.log("Connecting to peer:", peerIdToConnect);
        
        try {
          const conn = peerInstance.current.connect(peerIdToConnect, {
            reliable: true
          });
          
          conn.on('open', () => {
            console.log("Successfully connected to:", peerIdToConnect);
            setConnections(prev => {
              if (prev.some(c => c.peer === conn.peer)) {
                return prev;
              }
              return [...prev, conn];
            });
          });

          conn.on('data', (data) => {
            console.log("Received data from connected peer:", data.type);
            handleIncomingData(data, conn.peer);
          });

          conn.on('error', (err) => {
            console.error("Connection error:", err);
            alert(`Erro ao conectar com ${peerIdToConnect}: ${err}`);
          });

          conn.on('close', () => {
            console.log("Connection closed with:", conn.peer);
            setConnections(prev => prev.filter(c => c.peer !== conn.peer));
          });
        } catch (err) {
          console.error("Error establishing connection:", err);
          alert(`Erro ao estabelecer conex√£o: ${err.message}`);
        }
      };

      const sendMessage = () => {
        if (!userName.trim()) {
          alert('Por favor, defina seu nome antes de enviar mensagens');
          setEditingName(true);
          return;
        }
        if (newMessage.trim() && connections.length > 0) {
          console.log("Sending text message to", connections.length, "peers");
          
          connections.forEach(conn => {
            try {
              conn.send({ 
                type: 'message', 
                text: newMessage,
                senderName: userName
              });
            } catch (err) {
              console.error("Error sending message to", conn.peer, err);
            }
          });
          
          setMessages(prev => [...prev, {
            text: newMessage,
            sender: 'you',
            senderName: userName,
            time: new Date().toLocaleTimeString(),
            type: 'text'
          }]);
          
          setNewMessage('');
        }
      };

      const handleFileChange = () => {
        if (!userName.trim()) {
          alert('Por favor, defina seu nome antes de enviar arquivos');
          setEditingName(true);
          return;
        }
        const file = fileInputRef.current.files[0];
        if (!file || connections.length === 0) return;

        console.log("Sending file:", file.name, "size:", file.size);
        const fileId = Date.now();
        const reader = new FileReader();
        let offset = 0;

        setMessages(prev => [...prev, {
          fileId,
          fileName: file.name,
          sender: 'you',
          senderName: userName,
          time: new Date().toLocaleTimeString(),
          type: 'file',
          sending: true,
          progress: 0
        }]);

        connections.forEach(conn => {
          try {
            conn.send({
              type: 'file-start',
              fileId,
              fileName: file.name,
              fileSize: file.size,
              senderName: userName
            });
          } catch (err) {
            console.error("Error sending file-start to", conn.peer, err);
          }
        });

        const readChunk = () => {
          const chunk = file.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (e) => {
          const chunkBuffer = new Uint8Array(e.target.result);
          
          connections.forEach(conn => {
            try {
              conn.send({
                type: 'file-chunk',
                fileId,
                chunk: chunkBuffer.buffer,
                offset: offset
              });
            } catch (err) {
              console.error("Error sending file chunk to", conn.peer, err);
            }
          });

          offset += chunkBuffer.length;
          const progress = Math.floor((offset / file.size) * 100);
          
          setMessages(prev => prev.map(msg => 
            msg.fileId === fileId ? { ...msg, progress } : msg
          ));

          if (offset < file.size) {
            readChunk();
          } else {
            setMessages(prev => prev.map(msg => 
              msg.fileId === fileId ? { ...msg, sending: false } : msg
            ));
          }
        };

        readChunk();
        fileInputRef.current.value = '';
      };

      const handleAudioRecording = (audioBlob) => {
        if (!userName.trim()) {
          alert('Por favor, defina seu nome antes de enviar √°udios');
          setEditingName(true);
          return;
        }
        if (!connections.length) {
          console.error("No connections available to send audio");
          return;
        }
        
        console.log("Processing audio recording, size:", audioBlob.size);
        const audioId = Date.now();
        const reader = new FileReader();
        let offset = 0;

        const audioUrl = URL.createObjectURL(audioBlob);

        setMessages(prev => [...prev, {
          audioId,
          sender: 'you',
          senderName: userName,
          time: new Date().toLocaleTimeString(),
          type: 'audio',
          sending: true,
          progress: 0,
          audioData: audioUrl
        }]);

        connections.forEach(conn => {
          try {
            console.log("Sending audio-start to", conn.peer);
            conn.send({
              type: 'audio-start',
              audioId,
              audioSize: audioBlob.size,
              senderName: userName
            });
          } catch (err) {
            console.error("Error sending audio-start to", conn.peer, err);
          }
        });

        const readChunk = () => {
          const chunk = audioBlob.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (e) => {
          const chunkBuffer = new Uint8Array(e.target.result);
          
          connections.forEach(conn => {
            try {
              conn.send({
                type: 'audio-chunk',
                audioId,
                chunk: chunkBuffer.buffer,
                offset: offset
              });
            } catch (err) {
              console.error("Error sending audio chunk to", conn.peer, err);
            }
          });

          offset += chunkBuffer.length;
          const progress = Math.floor((offset / audioBlob.size) * 100);
          
          setMessages(prev => prev.map(msg => 
            msg.audioId === audioId ? { ...msg, progress } : msg
          ));

          if (offset < audioBlob.size) {
            readChunk();
          } else {
            setMessages(prev => prev.map(msg => 
              msg.audioId === audioId ? { ...msg, sending: false } : msg
            ));
            console.log("Audio sending complete");
          }
        };

        readChunk();
      };

      const selectVideoDevice = async () => {
        try {
          await navigator.mediaDevices.getUserMedia({ video: true });
          
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          
          if (videoDevices.length === 0) {
            throw new Error('Nenhuma webcam encontrada.');
          }
          
          if (videoDevices.length === 1) {
            return videoDevices[0].deviceId;
          }
          
          const deviceOptions = videoDevices
            .map((device, index) => `${index + 1}. ${device.label || `Webcam ${index + 1}`}`)
            .join('\n');
          
          const selection = prompt(
            `Selecione uma webcam:\n${deviceOptions}\nDigite o n√∫mero da webcam desejada:`
          );
          
          const selectedIndex = parseInt(selection, 10) - 1;
          if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= videoDevices.length) {
            throw new Error('Sele√ß√£o inv√°lida. Usando a webcam padr√£o.');
          }
          
          return videoDevices[selectedIndex].deviceId;
        } catch (err) {
          console.error('Erro ao selecionar dispositivo de v√≠deo:', err);
          alert('Erro ao selecionar webcam: ' + err.message);
          return null;
        }
      };

      const startVoiceCall = async (peerIdToCall) => {
        if (!peerInstance.current) {
          alert('Peer n√£o inicializado');
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'voice' } });

          setActiveCalls(prev => [...prev, {
            peerId: peerIdToCall,
            call,
            localStream: stream
          }]);

          call.on('stream', (remoteStream) => {
            const audio = new Audio();
            audio.srcObject = remoteStream;
            audio.play().catch(err => console.error('Erro ao reproduzir √°udio:', err));
          });

          call.on('close', () => {
            endCall(peerIdToCall);
          });

          call.on('error', (err) => {
            console.error('Erro na chamada de voz:', err);
            alert('Erro na chamada de voz: ' + err.message);
            endCall(peerIdToCall);
          });
        } catch (err) {
          console.error('Erro ao iniciar chamada de voz:', err);
          alert('Erro ao acessar o microfone: ' + err.message);
        }
      };

      const startVideoCall = async (peerIdToCall) => {
        if (!peerInstance.current) {
          alert('Peer n√£o inicializado');
          return;
        }

        try {
          const deviceId = await selectVideoDevice();
          
          const constraints = {
            video: deviceId ? { deviceId: { exact: deviceId } } : true,
            audio: true
          };

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'video' } });

          setActiveCalls(prev => [...prev, {
            peerId: peerIdToCall,
            call,
            localStream: stream
          }]);

          call.on('stream', (remoteStream) => {
            console.log(`Recebido stream de ${peerIdToCall}`);
            setRemoteStreams(prev => {
              const exists = prev.some(s => s.peerId === peerIdToCall);
              if (exists) {
                return prev.map(s => s.peerId === peerIdToCall ? { peerId: peerIdToCall, stream: remoteStream } : s);
              }
              return [...prev, { peerId: peerIdToCall, stream: remoteStream }];
            });
          });

          call.on('close', () => {
            endCall(peerIdToCall);
          });

          call.on('error', (err) => {
            console.error('Erro na chamada de v√≠deo:', err);
            alert('Erro na chamada de v√≠deo: ' + err.message);
            endCall(peerIdToCall);
          });
        } catch (err) {
          console.error('Erro ao iniciar chamada de v√≠deo:', err);
          alert('Erro ao acessar a c√¢mera/microfone: ' + err.message);
        }
      };

      const endCall = (peerIdToEnd) => {
        setActiveCalls(prev => {
          const callData = prev.find(c => c.peerId === peerIdToEnd);
          if (callData) {
            if (callData.localStream) {
              callData.localStream.getTracks().forEach(track => {
                track.stop();
                console.log('Stream local encerrado:', track.kind);
              });
            }
            if (callData.call) {
              callData.call.close();
              console.log('Chamada encerrada com:', peerIdToEnd);
            }
          }
          return prev.filter(c => c.peerId !== peerIdToEnd);
        });

        setRemoteStreams(prev => prev.filter(s => s.peerId !== peerIdToEnd));
      };

      const renderNameForm = () => (
        <div className="user-name-form">
          <input
            type="text"
            value={userName}
            onChange={(e) => setUserName(e.target.value)}
            placeholder="Digite seu nome"
            required
          />
          <button onClick={saveUserName} disabled={!userName.trim()}>
            Salvar
          </button>
        </div>
      );

      return (
        <div>
          {!showContacts ? (
            <div>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <h1>PSA</h1>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button onClick={() => setShowContacts(true)}>
                    <i className="fas fa-address-book"></i> Contatos
                  </button>
                  <button 
                    className="call-button"
                    onClick={() => {
                      if (connections.length === 0) {
                        alert('Nenhum contato conectado para chamar.');
                        return;
                      }
                      if (connections.length === 1) {
                        startVoiceCall(connections[0].peer);
                      } else {
                        const peerIdToCall = prompt(
                          'Digite o ID do contato para chamada de voz:\n' + 
                          connections.map(c => `${getContactName(c.peer)} (${c.peer})`).join('\n')
                        );
                        if (peerIdToCall && connections.some(c => c.peer === peerIdToCall)) {
                          startVoiceCall(peerIdToCall);
                        } else if (peerIdToCall) {
                          alert('ID inv√°lido ou contato n√£o conectado.');
                        }
                      }
                    }}
                    title="Iniciar chamada de voz"
                    disabled={connections.length === 0}
                  >
                    <i className="fas fa-phone button-icon"></i>
                  </button>
                  <button 
                    className="call-button"
                    onClick={() => {
                      if (connections.length === 0) {
                        alert('Nenhum contato conectado para videochamada.');
                        return;
                      }
                      if (connections.length === 1) {
                        startVideoCall(connections[0].peer);
                      } else {
                        const peerIdToCall = prompt(
                          'Digite o ID do contato para videochamada:\n' + 
                          connections.map(c => `${getContactName(c.peer)} (${c.peer})`).join('\n')
                        );
                        if (peerIdToCall && connections.some(c => c.peer === peerIdToCall)) {
                          startVideoCall(peerIdToCall);
                        } else if (peerIdToCall) {
                          alert('ID inv√°lido ou contato n√£o conectado.');
                        }
                      }
                    }}
                    title="Iniciar videochamada"
                    disabled={connections.length === 0}
                  >
                    <i className="fas fa-video button-icon"></i>
                  </button>
                </div>
              </div>
              
              <div className="user-info-container">
                {editingName ? (
                  renderNameForm()
                ) : (
                  <div style={{ display: 'flex', justifyContent: 'space-between', width: '100%' }}>
                    <span>Seu nome: <span className="username">{userName}</span></span>
                    <button onClick={() => setEditingName(true)} style={{ padding: '4px 8px' }}>
                      ‚úèÔ∏è Editar
                    </button>
                  </div>
                )}
              </div>
              
              <div className="peer-id-container">
                <span>Seu ID Fixo: <strong>{peerId || 'Gerando...'}</strong></span>
              </div>

              {remoteStreams.length > 0 && (
                <div className="video-container">
                  {remoteStreams.map(({ peerId, stream }) => (
                    <div key={peerId}>
                      <video
                        ref={el => videoRefs.current[peerId] = el}
                        className="video-player remote-video"
                        autoPlay
                      />
                      <p>V√≠deo de: {getContactName(peerId)}</p>
                      <button onClick={() => endCall(peerId)} style={{ background: '#ff0000' }}>
                        Encerrar Videochamada com {getContactName(peerId)}
                      </button>
                    </div>
                  ))}
                </div>
              )}

              {connections.length > 0 && (
                <div className="connected-peers">
                  <h3>Conex√µes Ativas: {connections.length}</h3>
                  {connections.map((conn, i) => (
                    <div key={i} className="peer-item">
                      {getContactName(conn.peer)}
                    </div>
                  ))}
                </div>
              )}

              <div style={{ 
                height: '300px', 
                border: '1px solid #ddd',
                padding: '10px',
                overflowY: 'scroll',
                marginBottom: '10px'
              }}>
                {messages.map((msg, i) => (
                  <div 
                    key={i}
                    className={`message ${msg.sender === 'you' ? 'you' : 'other'}`}
                  >
                    <div className="message-header">
                      <span>{msg.senderName || (msg.sender === 'you' ? userName : getContactName(msg.sender))}</span>
                      <span style={{ fontSize: '0.8em', color: '#666' }}>{msg.time}</span>
                    </div>
                    {msg.type === 'text' ? (
                      msg.text
                    ) : msg.type === 'file' ? (
                      <div>
                        {msg.fileData ? (
                          <a
                            href={msg.fileData}
                            download={msg.fileName}
                            className="file-link"
                          >
                            {msg.fileName}
                          </a>
                        ) : (
                          <span>{msg.fileName}</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div 
                                className="progress" 
                                style={{ width: `${msg.progress}%` }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    ) : msg.type === 'audio' && (
                      <div>
                        {msg.audioData ? (
                          <audio 
                            controls 
                            src={msg.audioData}
                            className="audio-player"
                          />
                        ) : (
                          <span>√Åudio</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div 
                                className="progress" 
                                style={{ width: `${msg.progress}%` }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>

              <div className="file-input-container">
                <VoiceRecorder 
                  onRecordingComplete={handleAudioRecording}
                  disabled={connections.length === 0}
                />
                <button 
                  onClick={() => fileInputRef.current.click()}
                  disabled={connections.length === 0}
                  title="Enviar arquivo"
                >
                  <i className="fas fa-paperclip"></i>
                </button>
                <input
                  type="file"
                  ref={fileInputRef}
                  style={{ display: 'none' }}
                  onChange={handleFileChange}
                />
                <input
                  type="text"
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  placeholder="Digite sua mensagem..."
                  onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                  style={{ flex: 1, marginRight: '10px' }}
                />
                <button 
                  onClick={sendMessage} 
                  disabled={connections.length === 0 || !newMessage.trim()}
                  title="Enviar mensagem"
                >
                  <i className="fas fa-paper-plane"></i>
                </button>
              </div>
            </div>
          ) : (
            <ContactsScreen 
              contacts={contacts}
              setContacts={setContacts}
              onBack={() => setShowContacts(false)}
              onSelectContact={(peerId) => {
                connectToPeer(peerId);
                setShowContacts(false);
              }}
            />
          )}
        </div>
      );
    };

    ReactDOM.render(
      <ErrorBoundary>
        <App />
      </ErrorBoundary>,
      document.getElementById('root')
    );
  </script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
