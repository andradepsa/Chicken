<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat P2P com Contatos</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    #root {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .peer-id-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .peer-id-input {
      flex: 1;
      margin-right: 10px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .message {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    .message.you {
      background-color: #e3f2fd;
      margin-left: 20%;
    }
    .message.other {
      background-color: #f1f1f1;
      margin-right: 20%;
    }
    .file-link {
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .progress-container {
      margin-top: 5px;
    }
    .progress-bar {
      height: 5px;
      background: #ddd;
      border-radius: 3px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #4CAF50;
      width: 0%;
      transition: width 0.3s ease;
    }
    .connected-peers {
      margin-top: 10px;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .peer-item {
      margin: 5px 0;
      padding: 5px;
      background: #e3f2fd;
      border-radius: 3px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .voice-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .voice-button.recording {
      background: #ff0000;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .button-icon {
      color: white;
      font-size: 16px;
    }
    .audio-player {
      margin-top: 5px;
      width: 100%;
    }
    /* Form styling */
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .contact-form-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .contact-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    /* Nova estilização para a lista de contatos */
    .contacts-list {
      max-height: 300px;
      overflow-y: auto;
      border-right: 4px solid #4CAF50;
      padding-right: 10px;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const usePersistentId = () => {
      const [peerId, setPeerId] = useState('');

      useEffect(() => {
        const generateId = () => {
          const savedId = localStorage.getItem('p2pChatId');
          if (savedId) return savedId;
          
          const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
          const buffer = new Uint8Array(6);
          crypto.getRandomValues(buffer);
          const newId = Array.from(buffer)
            .map(b => chars[b % chars.length])
            .join('');
          
          localStorage.setItem('p2pChatId', newId);
          return newId;
        };
        setPeerId(generateId());
      }, []);

      return peerId;
    };

    const VoiceRecorder = ({ onRecordingComplete, disabled }) => {
      const [isRecording, setIsRecording] = useState(false);
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);

      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorderRef.current = new MediaRecorder(stream);
          
          mediaRecorderRef.current.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunksRef.current.push(event.data);
            }
          };
          
          mediaRecorderRef.current.onstop = () => {
            if (audioChunksRef.current.length === 0) {
              console.error("No audio data collected");
              return;
            }
            
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            onRecordingComplete(audioBlob);
            audioChunksRef.current = [];
            
            // Stop all tracks to release the microphone
            stream.getTracks().forEach(track => track.stop());
          };
          
          audioChunksRef.current = []; // Clear any previous chunks
          mediaRecorderRef.current.start(200); // Collect chunks more frequently
          setIsRecording(true);
        } catch (err) {
          alert('Erro ao acessar o microfone: ' + err);
          console.error(err);
        }
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          try {
            mediaRecorderRef.current.stop();
          } catch (err) {
            console.error("Error stopping media recorder:", err);
          }
          setIsRecording(false);
        }
      };

      const toggleRecording = () => {
        if (isRecording) {
          stopRecording();
        } else {
          startRecording();
        }
      };

      return (
        <button 
          className={`voice-button ${isRecording ? 'recording' : ''}`}
          onClick={toggleRecording}
          disabled={disabled}
          title="Gravar áudio"
        >
          <i className="fas fa-microphone button-icon"></i>
        </button>
      );
    };

    const ContactsScreen = ({ contacts, setContacts, onBack, onSelectContact }) => {
      const [newName, setNewName] = useState('');
      const [newPeerId, setNewPeerId] = useState('');
      const [nameError, setNameError] = useState('');
      const [idError, setIdError] = useState('');

      const validateForm = () => {
        let isValid = true;
        
        // Validação do nome
        if (!newName.trim()) {
          setNameError('Nome é obrigatório');
          isValid = false;
        } else {
          setNameError('');
        }
        
        // Validação do ID
        if (!newPeerId.trim()) {
          setIdError('ID é obrigatório');
          isValid = false;
        } else {
          setIdError('');
        }
        
        return isValid;
      };

      const handleAddContact = (e) => {
        e.preventDefault(); // Prevent form submission
        
        if (validateForm()) {
          const newContact = { name: newName, peerId: newPeerId };
          setContacts(prev => {
            const updated = [...prev, newContact];
            localStorage.setItem('p2pContacts', JSON.stringify(updated));
            return updated;
          });
          setNewName('');
          setNewPeerId('');
        }
      };

      const handleRemoveContact = (peerId, e) => {
        e.stopPropagation();
        setContacts(prev => {
          const updated = prev.filter(c => c.peerId !== peerId);
          localStorage.setItem('p2pContacts', JSON.stringify(updated));
          return updated;
        });
      };

      return (
        <div>
          <button onClick={onBack} style={{ marginBottom: '20px' }}>
            ← Voltar
          </button>
          <h2>Lista de Contatos</h2>
          
          <form className="contact-form" onSubmit={handleAddContact}>
            <div className="contact-form-row">
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="Nome do contato"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  style={{ borderColor: nameError ? 'red' : '#ddd' }}
                />
                {nameError && <span style={{ color: 'red', fontSize: '12px' }}>{nameError}</span>}
              </div>
              
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="ID do contato"
                  value={newPeerId}
                  onChange={(e) => setNewPeerId(e.target.value)}
                  style={{ borderColor: idError ? 'red' : '#ddd' }}
                />
                {idError && <span style={{ color: 'red', fontSize: '12px' }}>{idError}</span>}
              </div>
              
              <button type="submit">Adicionar</button>
            </div>
          </form>

          <div className="connected-peers contacts-list">
            {contacts.length === 0 ? (
              <p>Nenhum contato adicionado ainda.</p>
            ) : (
              contacts.map((contact, i) => (
                <div 
                  key={i} 
                  className="peer-item"
                  onClick={() => onSelectContact(contact.peerId)}
                >
                  <span style={{ flex: 1 }}>
                    {contact.name} - {contact.peerId}
                  </span>
                  <button 
                    onClick={(e) => handleRemoveContact(contact.peerId, e)}
                    style={{ marginLeft: '10px' }}
                  >
                    🗑️
                  </button>
                </div>
              ))
            )}
          </div>
        </div>
      );
    };

    const App = () => {
      const peerId = usePersistentId();
      const [connections, setConnections] = useState([]);
      const [messages, setMessages] = useState([]);
      const [newMessage, setNewMessage] = useState('');
      const [showContacts, setShowContacts] = useState(false);
      const [contacts, setContacts] = useState(() => {
        const saved = localStorage.getItem('p2pContacts');
        return saved ? JSON.parse(saved) : [];
      });
      
      const peerInstance = useRef(null);
      const fileInputRef = useRef(null);
      const pendingFiles = useRef({});
      const messagesEndRef = useRef(null);
      const CHUNK_SIZE = 16 * 1024;

      // Auto-scroll to bottom of messages
      useEffect(() => {
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
      }, [messages]);

      useEffect(() => {
        if (!peerId) return;

        const peer = new Peer(peerId, {
          host: '0.peerjs.com',
          port: 443,
          secure: true,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          },
          debug: 3
        });

        peer.on('open', (id) => {
          console.log("Connected to PeerJS with ID:", id);
        });

        peer.on('error', (err) => {
          console.error("PeerJS error:", err);
          alert(`Erro de conexão: ${err.type}`);
        });

        peer.on('connection', (conn) => {
          console.log("Incoming connection from:", conn.peer);
          
          conn.on('open', () => {
            console.log("Connection opened with:", conn.peer);
            setConnections(prev => [...prev, conn]);
          });

          conn.on('data', (data) => {
            console.log("Received data from:", conn.peer, data.type);
            handleIncomingData(data, conn.peer);
          });

          conn.on('close', () => {
            console.log("Connection closed with:", conn.peer);
            setConnections(prev => prev.filter(c => c.peer !== conn.peer));
          });

          conn.on('error', (err) => {
            console.error("Connection error with:", conn.peer, err);
          });
        });

        peerInstance.current = peer;

        return () => {
          console.log("Destroying peer connection");
          peer.destroy();
        };
      }, [peerId]);

      const handleIncomingData = (data, peerId) => {
        console.log("Processing incoming data of type:", data.type);
        
        if (data.type === 'message') {
          setMessages(prev => [...prev, {
            text: data.text,
            sender: peerId,
            time: new Date().toLocaleTimeString(),
            type: 'text'
          }]);
        } else if (data.type === 'file-start') {
          pendingFiles.current[data.fileId] = {
            fileName: data.fileName,
            chunks: new Uint8Array(data.fileSize),
            receivedBytes: 0,
            totalSize: data.fileSize
          };
          
          setMessages(prev => [...prev, {
            fileId: data.fileId,
            fileName: data.fileName,
            sender: peerId,
            time: new Date().toLocaleTimeString(),
            type: 'file',
            receiving: true,
            progress: 0
          }]);
        } else if (data.type === 'file-chunk') {
          const fileData = pendingFiles.current[data.fileId];
          if (fileData) {
            const chunk = new Uint8Array(data.chunk);
            fileData.chunks.set(chunk, data.offset);
            fileData.receivedBytes += chunk.length;
            
            const progress = Math.floor((fileData.receivedBytes / fileData.totalSize) * 100);
            
            setMessages(prev => prev.map(msg => 
              msg.fileId === data.fileId ? { ...msg, progress } : msg
            ));

            if (fileData.receivedBytes === fileData.totalSize) {
              const blob = new Blob([fileData.chunks], { type: 'application/octet-stream' });
              const url = URL.createObjectURL(blob);
              
              setMessages(prev => prev.map(msg => 
                msg.fileId === data.fileId ? { 
                  ...msg, 
                  fileData: url,
                  receiving: false
                } : msg
              ));
              
              delete pendingFiles.current[data.fileId];
            }
          }
        } else if (data.type === 'audio-start') {
          console.log("Received audio-start:", data);
          pendingFiles.current[data.audioId] = {
            chunks: new Uint8Array(data.audioSize),
            receivedBytes: 0,
            totalSize: data.audioSize
          };
          
          setMessages(prev => [...prev, {
            audioId: data.audioId,
            sender: peerId,
            time: new Date().toLocaleTimeString(),
            type: 'audio',
            receiving: true,
            progress: 0
          }]);
        } else if (data.type === 'audio-chunk') {
          const audioData = pendingFiles.current[data.audioId];
          if (audioData) {
            const chunk = new Uint8Array(data.chunk);
            audioData.chunks.set(chunk, data.offset);
            audioData.receivedBytes += chunk.length;
            
            const progress = Math.floor((audioData.receivedBytes / audioData.totalSize) * 100);
            
            setMessages(prev => prev.map(msg => 
              msg.audioId === data.audioId ? { ...msg, progress } : msg
            ));

            if (audioData.receivedBytes === audioData.totalSize) {
              const blob = new Blob([audioData.chunks], { type: 'audio/webm' });
              const url = URL.createObjectURL(blob);
              
              setMessages(prev => prev.map(msg => 
                msg.audioId === data.audioId ? { 
                  ...msg, 
                  audioData: url,
                  receiving: false
                } : msg
              ));
              
              delete pendingFiles.current[data.audioId];
            }
          }
        }
      };

      const connectToPeer = (peerIdToConnect) => {
        if (!peerIdToConnect || !peerInstance.current) {
          console.error("Cannot connect: missing peer ID or peer instance");
          return;
        }

        console.log("Connecting to peer:", peerIdToConnect);
        
        try {
          const conn = peerInstance.current.connect(peerIdToConnect, {
            reliable: true
          });
          
          conn.on('open', () => {
            console.log("Successfully connected to:", peerIdToConnect);
            setConnections(prev => {
              // Avoid duplicate connections
              if (prev.some(c => c.peer === conn.peer)) {
                return prev;
              }
              return [...prev, conn];
            });
          });

          conn.on('data', (data) => {
            console.log("Received data from connected peer:", data.type);
            handleIncomingData(data, conn.peer);
          });

          conn.on('error', (err) => {
            console.error("Connection error:", err);
            alert(`Erro ao conectar com ${peerIdToConnect}: ${err}`);
          });

          conn.on('close', () => {
            console.log("Connection closed with:", conn.peer);
            setConnections(prev => prev.filter(c => c.peer !== conn.peer));
          });
        } catch (err) {
          console.error("Error establishing connection:", err);
          alert(`Erro ao estabelecer conexão: ${err.message}`);
        }
      };

      const sendMessage = () => {
        if (newMessage.trim() && connections.length > 0) {
          console.log("Sending text message to", connections.length, "peers");
          
          connections.forEach(conn => {
            try {
              conn.send({ type: 'message', text: newMessage });
            } catch (err) {
              console.error("Error sending message to", conn.peer, err);
            }
          });
          
          setMessages(prev => [...prev, {
            text: newMessage,
            sender: 'you',
            time: new Date().toLocaleTimeString(),
            type: 'text'
          }]);
          
          setNewMessage('');
        }
      };

      const handleFileChange = () => {
        const file = fileInputRef.current.files[0];
        if (!file || connections.length === 0) return;

        console.log("Sending file:", file.name, "size:", file.size);
        const fileId = Date.now();
        const reader = new FileReader();
        let offset = 0;

        setMessages(prev => [...prev, {
          fileId,
          fileName: file.name,
          sender: 'you',
          time: new Date().toLocaleTimeString(),
          type: 'file',
          sending: true,
          progress: 0
        }]);

        connections.forEach(conn => {
          try {
            conn.send({
              type: 'file-start',
              fileId,
              fileName: file.name,
              fileSize: file.size
            });
          } catch (err) {
            console.error("Error sending file-start to", conn.peer, err);
          }
        });

        const readChunk = () => {
          const chunk = file.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (e) => {
          const chunkBuffer = new Uint8Array(e.target.result);
          
          connections.forEach(conn => {
            try {
              conn.send({
                type: 'file-chunk',
                fileId,
                chunk: chunkBuffer.buffer,
                offset: offset
              });
            } catch (err) {
              console.error("Error sending file chunk to", conn.peer, err);
            }
          });

          offset += chunkBuffer.length;
          const progress = Math.floor((offset / file.size) * 100);
          
          setMessages(prev => prev.map(msg => 
            msg.fileId === fileId ? { ...msg, progress } : msg
          ));

          if (offset < file.size) {
            readChunk();
          } else {
            setMessages(prev => prev.map(msg => 
              msg.fileId === fileId ? { ...msg, sending: false } : msg
            ));
          }
        };

        readChunk();
        fileInputRef.current.value = '';
      };

      const handleAudioRecording = (audioBlob) => {
        if (!connections.length) {
          console.error("No connections available to send audio");
          return;
        }
        
        console.log("Processing audio recording, size:", audioBlob.size);
        const audioId = Date.now();
        const reader = new FileReader();
        let offset = 0;

        // Create a URL for local playback
        const audioUrl = URL.createObjectURL(audioBlob);

        setMessages(prev => [...prev, {
          audioId,
          sender: 'you',
          time: new Date().toLocaleTimeString(),
          type: 'audio',
          sending: true,
          progress: 0,
          audioData: audioUrl
        }]);

        // Notify peers that we're sending audio
        connections.forEach(conn => {
          try {
            console.log("Sending audio-start to", conn.peer);
            conn.send({
              type: 'audio-start',
              audioId,
              audioSize: audioBlob.size
            });
          } catch (err) {
            console.error("Error sending audio-start to", conn.peer, err);
          }
        });

        const readChunk = () => {
          const chunk = audioBlob.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (e) => {
          const chunkBuffer = new Uint8Array(e.target.result);
          
          connections.forEach(conn => {
            try {
              conn.send({
                type: 'audio-chunk',
                audioId,
                chunk: chunkBuffer.buffer,
                offset: offset
              });
            } catch (err) {
              console.error("Error sending audio chunk to", conn.peer, err);
            }
          });

          offset += chunkBuffer.length;
          const progress = Math.floor((offset / audioBlob.size) * 100);
          
          setMessages(prev => prev.map(msg => 
            msg.audioId === audioId ? { ...msg, progress } : msg
          ));

          if (offset < audioBlob.size) {
            readChunk();
          } else {
            setMessages(prev => prev.map(msg => 
              msg.audioId === audioId ? { ...msg, sending: false } : msg
            ));
            console.log("Audio sending complete");
          }
        };

        readChunk();
      };

      return (
        <div>
          {!showContacts ? (
            <div>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <h1>PSA</h1>
                <button onClick={() => setShowContacts(true)}>
                  📋 Contatos
                </button>
              </div>
              
              <div className="peer-id-container">
                <span>Seu ID Fixo: <strong>{peerId || 'Gerando...'}</strong></span>
              </div>

              {connections.length > 0 && (
                <div className="connected-peers">
                  <h3>Conexões Ativas: {connections.length}</h3>
                  {connections.map((conn, i) => (
                    <div key={i} className="peer-item">
                      {conn.peer}
                    </div>
                  ))}
                </div>
              )}

              <div style={{ 
                height: '300px', 
                border: '1px solid #ddd',
                padding: '10px',
                overflowY: 'scroll',
                marginBottom: '10px'
              }}>
                {messages.map((msg, i) => (
                  <div 
                    key={i}
                    className={`message ${msg.sender === 'you' ? 'you' : 'other'}`}
                  >
                    {msg.type === 'text' ? (
                      msg.text
                    ) : msg.type === 'file' ? (
                      <div>
                        {msg.fileData ? (
                          <a
                            href={msg.fileData}
                            download={msg.fileName}
                            className="file-link"
                          >
                            {msg.fileName}
                          </a>
                        ) : (
                          <span>{msg.fileName}</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div 
                                className="progress" 
                                style={{ width: `${msg.progress}%` }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    ) : msg.type === 'audio' && (
                      <div>
                        {msg.audioData ? (
                          <audio 
                            controls 
                            src={msg.audioData}
                            className="audio-player"
                          />
                        ) : (
                          <span>Áudio</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div 
                                className="progress" 
                                style={{ width: `${msg.progress}%` }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                    <div style={{ fontSize: '0.8em', color: '#666' }}>
                      {msg.time} {msg.sender === 'you' ? '(Você)' : ''}
                    </div>
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>

              <div className="file-input-container">
                <VoiceRecorder 
                  onRecordingComplete={handleAudioRecording}
                  disabled={connections.length === 0}
                />
                <button 
                  onClick={() => fileInputRef.current.click()}
                  disabled={connections.length === 0}
                  title="Enviar arquivo"
                >
                  <i className="fas fa-paperclip"></i>
                </button>
                <input
                  type="file"
                  ref={fileInputRef}
                  style={{ display: 'none' }}
                  onChange={handleFileChange}
                />
                <input
                  type="text"
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  placeholder="Digite sua mensagem..."
                  onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                  style={{ flex: 1, marginRight: '10px' }}
                />
                <button 
                  onClick={sendMessage} 
                  disabled={connections.length === 0 || !newMessage.trim()}
                  title="Enviar mensagem"
                >
                  <i className="fas fa-paper-plane"></i>
                </button>
              </div>
            </div>
          ) : (
            <ContactsScreen 
              contacts={contacts}
              setContacts={setContacts}
              onBack={() => setShowContacts(false)}
              onSelectContact={(peerId) => {
                connectToPeer(peerId);
                setShowContacts(false);
              }}
            />
          )}
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
