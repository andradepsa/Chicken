<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat P2P com Contatos</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    #root {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .peer-id-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .user-info-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 10px;
      background: #f0f8ff;
      border-radius: 5px;
    }
    .user-name-form {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .peer-id-input {
      flex: 1;
      margin-right: 10px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .message {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    .message.you {
      background-color: #e3f2fd;
      margin-left: 20%;
    }
    .message.other {
      background-color: #f1f1f1;
      margin-right: 20%;
    }
    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .file-link {
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .progress-container {
      margin-top: 5px;
    }
    .progress-bar {
      height: 5px;
      background: #ddd;
      border-radius: 3px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #4CAF50;
      width: 0%;
      transition: width 0.3s ease;
    }
    .connected-peers {
      margin-top: 10px;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .peer-item {
      margin: 5px 0;
      padding: 5px;
      background: #e3f2fd;
      border-radius: 3px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .voice-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .voice-button.recording {
      background: #ff0000;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .button-icon {
      color: white;
      font-size: 16px;
    }
    .audio-player {
      margin-top: 5px;
      width: 100%;
    }
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .contact-form-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .contact-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .contacts-list {
      max-height: 300px;
      overflow-y: auto;
      border-right: 4px solid #4CAF50;
      padding-right: 10px;
    }
    .username {
      font-weight: bold;
      color: #1976d2;
    }
    .call-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 10px;
    }
    .call-button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .active-call-indicator {
      display: inline-flex;
      align-items: center;
      background-color: #ff5722;
      color: white;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 12px;
      margin-left: 8px;
    }
    .audio-call-container {
      background-color: #e8f5e9;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #c8e6c9;
    }
    .call-end-button {
      background: #ff0000;
    }
    .error-message {
      color: red;
      padding: 20px;
      border: 1px solid red;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    .video-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    .video-player {
      width: 200px;
      height: 150px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #000;
    }
    .video-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>

  <script type="text/babel">
    console.log("Script started loading");

    const { useState, useEffect, useRef } = React;

    class ErrorBoundary extends React.Component {
      state = { error: null };

      static getDerivedStateFromError(error) {
        console.error("ErrorBoundary caught error:", error);
        return { error };
      }

      render() {
        if (this.state.error) {
          return (
            <div className="error-message">
              <h1>Erro na aplica√ß√£o</h1>
              <p>{this.state.error.message}</p>
              <p>Verifique o console do navegador para mais detalhes.</p>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const PEER_ID_STORAGE_KEY = 'p2pChatClientId';

    const usePersistentId = () => {
      const [peerId, setPeerId] = useState('');

      const generateId = () => {
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        const buffer = new Uint8Array(6);
        crypto.getRandomValues(buffer);
        return Array.from(buffer)
          .map(b => chars[b % chars.length])
          .join('');
      };

      useEffect(() => {
        console.log("usePersistentId: Loading or generating ID");
        const loadOrGenerateId = () => {
          const savedId = localStorage.getItem(PEER_ID_STORAGE_KEY);
          if (savedId) {
            console.log("usePersistentId: Loaded saved ID:", savedId);
            setPeerId(savedId);
          } else {
            const newId = generateId();
            console.log("usePersistentId: Generated new ID:", newId);
            localStorage.setItem(PEER_ID_STORAGE_KEY, newId);
            setPeerId(newId);
          }
        };
        loadOrGenerateId();
      }, []);

      return [peerId, setPeerId];
    };

    const VoiceRecorder = ({ onRecordingComplete, disabled }) => {
      const [isRecording, setIsRecording] = useState(false);
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);

      const startRecording = async () => {
        try {
          console.log("VoiceRecorder: Starting recording");
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorderRef.current = new MediaRecorder(stream);
          
          mediaRecorderRef.current.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunksRef.current.push(event.data);
            }
          };
          
          mediaRecorderRef.current.onstop = () => {
            if (audioChunksRef.current.length === 0) {
              console.error("VoiceRecorder: No audio data collected");
              return;
            }
            
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            console.log("VoiceRecorder: Recording stopped, blob size:", audioBlob.size);
            onRecordingComplete(audioBlob);
            audioChunksRef.current = [];
            
            stream.getTracks().forEach(track => track.stop());
          };
          
          audioChunksRef.current = [];
          mediaRecorderRef.current.start(200);
          setIsRecording(true);
        } catch (err) {
          console.error("VoiceRecorder: Error accessing microphone:", err);
          alert('Erro ao acessar o microfone: ' + err.message);
        }
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          try {
            mediaRecorderRef.current.stop();
            console.log("VoiceRecorder: Stopping recording");
          } catch (err) {
            console.error("VoiceRecorder: Error stopping media recorder:", err);
          }
          setIsRecording(false);
        }
      };

      const toggleRecording = () => {
        if (isRecording) {
          stopRecording();
        } else {
          startRecording();
        }
      };

      return (
        <button 
          className={`voice-button ${isRecording ? 'recording' : ''}`}
          onClick={toggleRecording}
          disabled={disabled}
          title="Gravar √°udio"
        >
          <i className="fas fa-microphone button-icon"></i>
        </button>
      );
    };

    const ContactsScreen = ({ contacts, setContacts, onBack, onSelectContact }) => {
      const [newName, setNewName] = useState('');
      const [newPeerId, setNewPeerId] = useState('');
      const [nameError, setNameError] = useState('');
      const [idError, setIdError] = useState('');

      const validateForm = () => {
        let isValid = true;
        
        if (!newName.trim()) {
          setNameError('Nome √© obrigat√≥rio');
          isValid = false;
        } else {
          setNameError('');
        }
        
        if (!newPeerId.trim()) {
          setIdError('ID √© obrigat√≥rio');
          isValid = false;
        } else {
          setIdError('');
        }
        
        return isValid;
      };

      const handleAddContact = (e) => {
        e.preventDefault();
        
        if (validateForm()) {
          const newContact = { name: newName, peerId: newPeerId };
          console.log("ContactsScreen: Adding contact:", newContact);
          setContacts(prev => {
            const updated = [...prev, newContact];
            localStorage.setItem('p2pContacts', JSON.stringify(updated));
            return updated;
          });
          setNewName('');
          setNewPeerId('');
        }
      };

      const handleRemoveContact = (peerId, e) => {
        e.stopPropagation();
        console.log("ContactsScreen: Removing contact with peerId:", peerId);
        setContacts(prev => {
          const updated = prev.filter(c => c.peerId !== peerId);
          localStorage.setItem('p2pContacts', JSON.stringify(updated));
          return updated;
        });
      };

      return (
        <div>
          <button onClick={onBack} style={{ marginBottom: '20px' }}>
            ‚Üê Voltar
          </button>
          <h2>Lista de Contatos</h2>
          
          <form className="contact-form" onSubmit={handleAddContact}>
            <div className="contact-form-row">
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="Nome do contato"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  style={{ borderColor: nameError ? 'red' : '#ddd' }}
                />
                {nameError && <span style={{ color: 'red', fontSize: '12px' }}>{nameError}</span>}
              </div>
              
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="ID do contato"
                  value={newPeerId}
                  onChange={(e) => setNewPeerId(e.target.value)}
                  style={{ borderColor: idError ? 'red' : '#ddd' }}
                />
                {idError && <span style={{ color: 'red', fontSize: '12px' }}>{idError}</span>}
              </div>
              
              <button type="submit">Adicionar</button>
            </div>
          </form>

          <div className="connected-peers contacts-list">
            {contacts.length === 0 ? (
              <p>Nenhum contato adicionado ainda.</p>
            ) : (
              contacts.map((contact, i) => (
                <div 
                  key={i} 
                  className="peer-item"
                  onClick={() => onSelectContact(contact.peerId)}
                >
                  <span style={{ flex: 1 }}>
                    {contact.name} - {contact.peerId}
                  </span>
                  <button 
                    onClick={(e) => handleRemoveContact(contact.peerId, e)}
                    style={{ marginLeft: '10px' }}
                  >
                    üóëÔ∏è
                  </button>
                </div>
              ))
            )}
          </div>
        </div>
      );
    };

    const App = () => {
      console.log("App: Component rendering");
      const [peerId, setPeerId] = usePersistentId();
      const [userName, setUserName] = useState(() => {
        const savedName = localStorage.getItem('p2pUserName') || '';
        console.log("App: Loaded username:", savedName);
        return savedName;
      });
      const [editingName, setEditingName] = useState(!localStorage.getItem('p2pUserName'));
      const [connections, setConnections] = useState([]);
      const [messages, setMessages] = useState([]);
      const [newMessage, setNewMessage] = useState('');
      const [showContacts, setShowContacts] = useState(false);
      const [contacts, setContacts] = useState(() => {
        const saved = localStorage.getItem('p2pContacts');
        const parsed = saved ? JSON.parse(saved) : [];
        console.log("App: Loaded contacts:", parsed);
        return parsed;
      });
      const [activeCalls, setActiveCalls] = useState([]);
      const [remoteStreams, setRemoteStreams] = useState([]);
      const [error, setError] = useState(null);
      const [isBroadcasting, setIsBroadcasting] = useState(false);
      const [localStream, setLocalStream] = useState(null);

      const peerInstance = useRef(null);
      const fileInputRef = useRef(null);
      const pendingFiles = useRef({});
      const messagesEndRef = useRef(null);
      const audioRefs = useRef({});
      const videoRefs = useRef({});
      const CHUNK_SIZE = 16 * 1024;

      const generateNewId = () => {
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        const buffer = new Uint8Array(6);
        crypto.getRandomValues(buffer);
        const newId = Array.from(buffer)
          .map(b => chars[b % chars.length])
          .join('');
        console.log("App: Generated new ID:", newId);
        localStorage.setItem(PEER_ID_STORAGE_KEY, newId);
        return newId;
      };

      const getContactName = (peerId) => {
        const contact = contacts.find(c => c.peerId === peerId);
        return contact ? contact.name : peerId;
      };

      const saveUserName = () => {
        if (userName.trim()) {
          console.log("App: Saving username:", userName);
          localStorage.setItem('p2pUserName', userName);
          setEditingName(false);
        }
      };

      useEffect(() => {
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
      }, [messages]);

      useEffect(() => {
        remoteStreams.forEach(({ peerId, stream, type }) => {
          if (type === 'voice') {
            const audioElement = audioRefs.current[peerId];
            if (audioElement && audioElement.srcObject !== stream) {
              console.log("App: Assigning audio stream for peer:", peerId);
              audioElement.srcObject = stream;
            }
          } else if (type === 'video') {
            const videoElement = videoRefs.current[peerId];
            if (videoElement && videoElement.srcObject !== stream) {
              console.log("App: Assigning video stream for peer:", peerId);
              videoElement.srcObject = stream;
            }
          }
        });
      }, [remoteStreams]);

      useEffect(() => {
        if (!peerId) {
          console.log("App: No peerId yet, waiting...");
          return;
        }

        console.log("App: Initializing PeerJS with ID:", peerId);
        const createPeer = () => {
          try {
            const peer = new Peer(peerId, {
              host: '0.peerjs.com',
              port: 443,
              secure: true,
              config: {
                iceServers: [
                  { urls: 'stun:stun.l.google.com:19302' },
                  { urls: 'stun:stun1.l.google.com:19302' }
                ]
              },
              debug: 3
            });

            peer.on('open', (id) => {
              console.log("PeerJS: Connected with ID:", id);
            });

            peer.on('call', (call) => {
              const callType = call.metadata && call.metadata.type === 'voice' ? 'voice' : 'video';
              console.log(`PeerJS: Receiving ${callType} call from:`, call.peer);

              navigator.mediaDevices.getUserMedia({ 
                video: callType === 'video', 
                audio: true 
              })
              .then((stream) => {
                console.log(`PeerJS: Answering ${callType} call from:`, call.peer);
                call.answer(stream);
                setActiveCalls(prev => {
                  const newCall = {
                    peerId: call.peer,
                    call,
                    localStream: stream,
                    type: callType
                  };
                  return [...prev, newCall];
                });

                call.on('stream', (remoteStream) => {
                  console.log(`PeerJS: Received ${callType} stream from:`, call.peer);
                  setRemoteStreams(prev => {
                    const exists = prev.some(s => s.peerId === call.peer && s.type === callType);
                    if (exists) {
                      return prev.map(s => (s.peerId === call.peer && s.type === callType) 
                        ? { peerId: call.peer, stream: remoteStream, type: callType } 
                        : s);
                    }
                    return [...prev, { peerId: call.peer, stream: remoteStream, type: callType }];
                  });
                });

                call.on('close', () => {
                  console.log(`PeerJS: ${callType} call closed with:`, call.peer);
                  endCall(call.peer, callType);
                });

                call.on('error', (err) => {
                  console.error(`PeerJS: Error in ${callType} call:`, err);
                  alert(`Erro na chamada de ${callType === 'voice' ? 'voz' : 'v√≠deo'}: ` + err.message);
                  endCall(call.peer, callType);
                });
              })
              .catch((err) => {
                console.error(`PeerJS: Error answering ${callType} call:`, err);
                alert(`Erro ao acessar ${callType === 'voice' ? 'o microfone' : 'a c√¢mera/microfone'}: ` + err.message);
                call.close();
              });
            });

            peer.on('error', (err) => {
              console.error("PeerJS: Error:", err);
              if (err.type === 'peer-unavailable') {
                console.log("PeerJS: Peer unavailable, showing user-friendly message");
                alert("Usu√°rio offline");
              } else if (err.type === 'unavailable-id') {
                console.log("PeerJS: ID unavailable, generating new ID...");
                const newId = generateNewId();
                setPeerId(newId);
                peer.destroy();
              } else {
                setError(`Erro de conex√£o PeerJS: ${err.type}`);
                alert(`Erro de conex√£o: ${err.type}`);
              }
            });

            peer.on('connection', (conn) => {
              console.log("PeerJS: Incoming connection from:", conn.peer);
              
              conn.on('open', () => {
                console.log("PeerJS: Connection opened with:", conn.peer);
                setConnections(prev => {
                  if (!prev.some(c => c.peer === conn.peer)) {
                    return [...prev, conn];
                  }
                  return prev;
                });

                if (isBroadcasting && localStream) {
                  console.log("App: Automatically starting video call with new peer:", conn.peer);
                  startVideoCallWithPeer(conn.peer, localStream);
                }
              });

              conn.on('data', (data) => {
                console.log("PeerJS: Received data from:", conn.peer, data.type);
                handleIncomingData(data, conn.peer);
              });

              conn.on('close', () => {
                console.log("PeerJS: Connection closed with:", conn.peer);
                setConnections(prev => prev.filter(c => c.peer !== conn.peer));
                endCall(conn.peer, 'video');
              });

              conn.on('error', (err) => {
                console.error("PeerJS: Connection error with:", conn.peer, err);
              });
            });

            peerInstance.current = peer;
          } catch (err) {
            console.error("App: Error creating PeerJS instance:", err);
            setError(`Erro ao inicializar PeerJS: ${err.message}`);
          }
        };

        createPeer();

        return () => {
          console.log("App: Cleaning up PeerJS connection");
          if (peerInstance.current) {
            peerInstance.current.destroy();
          }
          activeCalls.forEach(({ peerId, type }) => endCall(peerId, type));
          stopBroadcast();
        };
      }, [peerId]);

      const handleIncomingData = (data, peerId) => {
        console.log("App: Processing incoming data of type:", data.type);
        
        if (data.type === 'message') {
          setMessages(prev => [...prev, {
            text: data.text,
            sender: peerId,
            senderName: data.senderName || getContactName(peerId),
            time: new Date().toLocaleTimeString(),
            type: 'text'
          }]);
        } else if (data.type === 'file-start') {
          pendingFiles.current[data.fileId] = {
            fileName: data.fileName,
            chunks: new Uint8Array(data.fileSize),
            receivedBytes: 0,
            totalSize: data.fileSize
          };
          
          setMessages(prev => [...prev, {
            fileId: data.fileId,
            fileName: data.fileName,
            sender: peerId,
            senderName: data.senderName || getContactName(peerId),
            time: new Date().toLocaleTimeString(),
            type: 'file',
            receiving: true,
            progress: 0
          }]);
        } else if (data.type === 'file-chunk') {
          const fileData = pendingFiles.current[data.fileId];
          if (fileData) {
            const chunk = new Uint8Array(data.chunk);
            fileData.chunks.set(chunk, data.offset);
            fileData.receivedBytes += chunk.length;
            
            const progress = Math.floor((fileData.receivedBytes / fileData.totalSize) * 100);
            
            setMessages(prev => prev.map(msg => 
              msg.fileId === data.fileId ? { ...msg, progress } : msg
            ));

            if (fileData.receivedBytes === fileData.totalSize) {
              const blob = new Blob([fileData.chunks], { type: 'application/octet-stream' });
              const url = URL.createObjectURL(blob);
              
              setMessages(prev => prev.map(msg => 
                msg.fileId === data.fileId ? { 
                  ...msg, 
                  fileData: url,
                  receiving: false
                } : msg
              ));
              
              delete pendingFiles.current[data.fileId];
            }
          }
        } else if (data.type === 'audio-start') {
          console.log("App: Received audio-start:", data);
          pendingFiles.current[data.audioId] = {
            chunks: new Uint8Array(data.audioSize),
            receivedBytes: 0,
            totalSize: data.audioSize
          };
          
          setMessages(prev => [...prev, {
            audioId: data.audioId,
            sender: peerId,
            senderName: data.senderName || getContactName(peerId),
            time: new Date().toLocaleTimeString(),
            type: 'audio',
            receiving: true,
            progress: 0
          }]);
        } else if (data.type === 'audio-chunk') {
          const audioData = pendingFiles.current[data.audioId];
          if (audioData) {
            const chunk = new Uint8Array(data.chunk);
            audioData.chunks.set(chunk, data.offset);
            audioData.receivedBytes += chunk.length;
            
            const progress = Math.floor((audioData.receivedBytes / audioData.totalSize) * 100);
            
            setMessages(prev => prev.map(msg => 
              msg.audioId === data.audioId ? { ...msg, progress } : msg
            ));

            if (audioData.receivedBytes === audioData.totalSize) {
              const blob = new Blob([audioData.chunks], { type: 'audio/webm' });
              const url = URL.createObjectURL(blob);
              
              setMessages(prev => prev.map(msg => 
                msg.audioId === data.audioId ? { 
                  ...msg, 
                  audioData: url,
                  receiving: false
                } : msg
              ));
              
              delete pendingFiles.current[data.audioId];
            }
          }
        }
      };

      const connectToPeer = (peerIdToConnect) => {
        if (!peerIdToConnect || !peerInstance.current) {
          console.error("App: Cannot connect: missing peer ID or peer instance");
          alert("Erro: Peer n√£o inicializado ou ID inv√°lido");
          return;
        }

        console.log("App: Connecting to peer:", peerIdToConnect);
        
        try {
          const conn = peerInstance.current.connect(peerIdToConnect, {
            reliable: true
          });
          
          conn.on('open', () => {
            console.log("App: Successfully connected to:", peerIdToConnect);
            setConnections(prev => {
              if (prev.some(c => c.peer === conn.peer)) {
                return prev;
              }
              return [...prev, conn];
            });
          });

          conn.on('data', (data) => {
            console.log("App: Received data from connected peer:", data.type);
            handleIncomingData(data, conn.peer);
          });

          conn.on('error', (err) => {
            console.error("App: Connection error:", err);
            if (err.type === 'peer-unavailable') {
              console.log("App: Peer unavailable, showing user-friendly message");
              alert("Usu√°rio offline");
            } else {
              alert(`Erro ao conectar com ${peerIdToConnect}: ${err.message}`);
            }
          });

          conn.on('close', () => {
            console.log("App: Connection closed with:", conn.peer);
            setConnections(prev => prev.filter(c => c.peer !== conn.peer));
          });
        } catch (err) {
          console.error("App: Error establishing connection:", err);
          alert(`Erro ao estabelecer conex√£o: ${err.message}`);
        }
      };

      const sendMessage = () => {
        if (!userName.trim()) {
          console.log("App: Cannot send message: username not set");
          alert('Por favor, defina seu nome antes de enviar mensagens');
          setEditingName(true);
          return;
        }
        if (newMessage.trim() && connections.length > 0) {
          console.log("App: Sending text message to", connections.length, "peers");
          
          connections.forEach(conn => {
            try {
              conn.send({ 
                type: 'message', 
                text: newMessage,
                senderName: userName
              });
            } catch (err) {
              console.error("App: Error sending message to", conn.peer, err);
            }
          });
          
          setMessages(prev => [...prev, {
            text: newMessage,
            sender: 'you',
            senderName: userName,
            time: new Date().toLocaleTimeString(),
            type: 'text'
          }]);
          
          setNewMessage('');
        }
      };

      const handleFileChange = () => {
        if (!userName.trim()) {
          console.log("App: Cannot send file: username not set");
          alert('Por favor, defina seu nome antes de enviar arquivos');
          setEditingName(true);
          return;
        }
        const file = fileInputRef.current.files[0];
        if (!file || connections.length === 0) return;

        console.log("App: Sending file:", file.name, "size:", file.size);
        const fileId = Date.now();
        const reader = new FileReader();
        let offset = 0;

        setMessages(prev => [...prev, {
          fileId,
          fileName: file.name,
          sender: 'you',
          senderName: userName,
          time: new Date().toLocaleTimeString(),
          type: 'file',
          sending: true,
          progress: 0
        }]);

        connections.forEach(conn => {
          try {
            conn.send({
              type: 'file-start',
              fileId,
              fileName: file.name,
              fileSize: file.size,
              senderName: userName
            });
          } catch (err) {
            console.error("App: Error sending file-start to", conn.peer, err);
          }
        });

        const readChunk = () => {
          const chunk = file.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (e) => {
          const chunkBuffer = new Uint8Array(e.target.result);
          
          connections.forEach(conn => {
            try {
              conn.send({
                type: 'file-chunk',
                fileId,
                chunk: chunkBuffer.buffer,
                offset: offset
              });
            } catch (err) {
              console.error("App: Error sending file chunk to", conn.peer, err);
            }
          });

          offset += chunkBuffer.length;
          const progress = Math.floor((offset / file.size) * 100);
          
          setMessages(prev => prev.map(msg => 
            msg.fileId === fileId ? { ...msg, progress } : msg
          ));

          if (offset < file.size) {
            readChunk();
          } else {
            setMessages(prev => prev.map(msg => 
              msg.fileId === fileId ? { ...msg, sending: false } : msg
            ));
          }
        };

        readChunk();
        fileInputRef.current.value = '';
      };

      const handleAudioRecording = (audioBlob) => {
        if (!userName.trim()) {
          console.log("App: Cannot send audio: username not set");
          alert('Por favor, defina seu nome antes de enviar √°udios');
          setEditingName(true);
          return;
        }
        if (!connections.length) {
          console.error("App: No connections available to send audio");
          return;
        }
        
        console.log("App: Processing audio recording, size:", audioBlob.size);
        const audioId = Date.now();
        const reader = new FileReader();
        let offset = 0;

        const audioUrl = URL.createObjectURL(audioBlob);

        setMessages(prev => [...prev, {
          audioId,
          sender: 'you',
          senderName: userName,
          time: new Date().toLocaleTimeString(),
          type: 'audio',
          sending: true,
          progress: 0,
          audioData: audioUrl
        }]);

        connections.forEach(conn => {
          try {
            console.log("App: Sending audio-start to", conn.peer);
            conn.send({
              type: 'audio-start',
              audioId,
              audioSize: audioBlob.size,
              senderName: userName
            });
          } catch (err) {
            console.error("App: Error sending audio-start to", conn.peer, err);
          }
        });

        const readChunk = () => {
          const chunk = audioBlob.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (e) => {
          const chunkBuffer = new Uint8Array(e.target.result);
          
          connections.forEach(conn => {
            try {
              conn.send({
                type: 'audio-chunk',
                audioId,
                chunk: chunkBuffer.buffer,
                offset: offset
              });
            } catch (err) {
              console.error("App: Error sending audio chunk to", conn.peer, err);
            }
          });

          offset += chunkBuffer.length;
          const progress = Math.floor((offset / audioBlob.size) * 100);
          
          setMessages(prev => prev.map(msg => 
            msg.audioId === audioId ? { ...msg, progress } : msg
          ));

          if (offset < audioBlob.size) {
            readChunk();
          } else {
            setMessages(prev => prev.map(msg => 
              msg.audioId === audioId ? { ...msg, sending: false } : msg
            ));
            console.log("App: Audio sending complete");
          }
        };

        readChunk();
      };

      const selectVideoDevice = async () => {
        try {
          console.log("App: Selecting video device");
          await navigator.mediaDevices.getUserMedia({ video: true });
          
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          
          if (videoDevices.length === 0) {
            throw new Error('Nenhuma webcam encontrada.');
          }
          
          // Always use the first available video device to avoid using prompt()
          console.log("App: Using video device:", videoDevices[0].deviceId);
          return videoDevices[0].deviceId;
        } catch (err) {
          console.error('App: Error selecting video device:', err);
          alert('Erro ao selecionar webcam: ' + err.message);
          return null;
        }
      };

      const startVoiceCall = async (peerIdToCall) => {
        if (!peerInstance.current) {
          console.error("App: Cannot start voice call: Peer not initialized");
          alert('Peer n√£o inicializado');
          return;
        }

        try {
          console.log("App: Starting voice call with:", peerIdToCall);
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          
          const call = peerInstance.current.call(peerIdToCall, stream, { 
            metadata: { type: 'voice' } 
          });

          setActiveCalls(prev => [...prev, {
            peerId: peerIdToCall,
            call,
            localStream: stream,
            type: 'voice'
          }]);

          call.on('stream', (remoteStream) => {
            console.log(`App: Received audio stream from:`, peerIdToCall);
            
            setRemoteStreams(prev => {
              const exists = prev.some(s => s.peerId === peerIdToCall && s.type === 'voice');
              if (exists) {
                return prev.map(s => (s.peerId === peerIdToCall && s.type === 'voice') 
                  ? { peerId: peerIdToCall, stream: remoteStream, type: 'voice' } 
                  : s);
              }
              return [...prev, { peerId: peerIdToCall, stream: remoteStream, type: 'voice' }];
            });
          });

          call.on('close', () => {
            console.log("App: Voice call closed with:", peerIdToCall);
            endCall(peerIdToCall, 'voice');
          });

          call.on('error', (err) => {
            console.error('App: Error in voice call:', err);
            alert('Erro na chamada de voz: ' + err.message);
            endCall(peerIdToCall, 'voice');
          });
        } catch (err) {
          console.error('App: Error starting voice call:', err);
          alert('Erro ao acessar o microfone: ' + err.message);
        }
      };

      const startVideoCallWithPeer = (peerIdToCall, stream) => {
        if (!peerInstance.current) {
          console.error("App: Cannot start video call: Peer not initialized");
          alert('Peer n√£o inicializado');
          return;
        }

        try {
          console.log("App: Starting video call with:", peerIdToCall);
          const call = peerInstance.current.call(peerIdToCall, stream, { 
            metadata: { type: 'video' } 
          });

          setActiveCalls(prev => [...prev, {
            peerId: peerIdToCall,
            call,
            localStream: stream,
            type: 'video'
          }]);

          call.on('stream', (remoteStream) => {
            console.log(`App: Received video stream from:`, peerIdToCall);
            setRemoteStreams(prev => {
              const exists = prev.some(s => s.peerId === peerIdToCall && s.type === 'video');
              if (exists) {
                return prev.map(s => (s.peerId === peerIdToCall && s.type === 'video') 
                  ? { peerId: peerIdToCall, stream: remoteStream, type: 'video' } 
                  : s);
              }
              return [...prev, { peerId: peerIdToCall, stream: remoteStream, type: 'video' }];
            });
          });

          call.on('close', () => {
            console.log("App: Video call closed with:", peerIdToCall);
            endCall(peerIdToCall, 'video');
          });

          call.on('error', (err) => {
            console.error('App: Error in video call:', err);
            alert('Erro na chamada de v√≠deo: ' + err.message);
            endCall(peerIdToCall, 'video');
          });
        } catch (err) {
          console.error('App: Error starting video call:', err);
          alert('Erro ao iniciar videochamada: ' + err.message);
          setError(`Erro ao iniciar videochamada: ${err.message}`);
        }
      };

      const startBroadcast = async () => {
        if (!peerInstance.current) {
          console.error("App: Cannot start broadcast: Peer not initialized");
          alert('Peer n√£o inicializado');
          return;
        }

        if (connections.length === 0) {
          console.log("App: No connected peers for broadcast");
          alert('Nenhum contato conectado para transmitir v√≠deo.');
          return;
        }

        try {
          const deviceId = await selectVideoDevice();
          const constraints = {
            video: deviceId ? { deviceId: { exact: deviceId } } : true,
            audio: true
          };

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          setLocalStream(stream);
          setIsBroadcasting(true);

          connections.forEach(conn => {
            startVideoCallWithPeer(conn.peer, stream);
          });
        } catch (err) {
          console.error('App: Error starting broadcast:', err);
          alert('Erro ao acessar a c√¢mera/microfone: ' + err.message);
          setError(`Erro ao iniciar transmiss√£o: ${err.message}`);
        }
      };

      const stopBroadcast = () => {
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log("App: Stopped stream track:", track.kind);
          });
          setLocalStream(null);
        }
        setIsBroadcasting(false);
        activeCalls.forEach(({ peerId, type }) => {
          if (type === 'video') {
            endCall(peerId, 'video');
          }
        });
      };

      const endCall = (peerIdToEnd, callType) => {
        console.log(`App: Ending ${callType} call with:`, peerIdToEnd);
        setActiveCalls(prev => {
          const callsToEnd = prev.filter(c => c.peerId === peerIdToEnd && (!callType || c.type === callType));
          
          callsToEnd.forEach(callData => {
            if (callData.localStream && callData.localStream !== localStream) {
              callData.localStream.getTracks().forEach(track => {
                track.stop();
                console.log(`App: Stopped ${callData.type} stream track:`, track.kind);
              });
            }
            if (callData.call) {
              callData.call.close();
              console.log(`App: Closed ${callData.type} call with:`, peerIdToEnd);
            }
          });
          
          return prev.filter(c => c.peerId !== peerIdToEnd || (callType && c.type !== callType));
        });

        setRemoteStreams(prev => prev.filter(s => s.peerId !== peerIdToEnd || (callType && s.type !== callType)));
      };

      const renderNameForm = () => (
        <div className="user-name-form">
          <input
            type="text"
            value={userName}
            onChange={(e) => setUserName(e.target.value)}
            placeholder="Digite seu nome"
            required
          />
          <button onClick={saveUserName} disabled={!userName.trim()}>
            Salvar
          </button>
        </div>
      );

      if (error) {
        return (
          <div className="error-message">
            <h1>Erro na Aplica√ß√£o</h1>
            <p>{error}</p>
            <p>Verifique o console do navegador para mais detalhes.</p>
            <button onClick={() => window.location.reload()}>Recarregar</button>
          </div>
        );
      }

      return (
        <div>
          {!showContacts ? (
            <div>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <h1>PSA</h1>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button onClick={() => setShowContacts(true)}>
                    <i className="fas fa-address-book"></i> Contatos
                  </button>
                  <button 
                    className="call-button"
                    onClick={() => {
                      if (connections.length === 0) {
                        console.log("App: No connected peers for voice call");
                        alert('Nenhum contato conectado para chamar.');
                        return;
                      }
                      if (connections.length === 1) {
                        startVoiceCall(connections[0].peer);
                      } else {
                        const peerIdToCall = prompt(
                          'Digite o ID do contato para chamada de voz:\n' + 
                          connections.map(c => `${getContactName(c.peer)} (${c.peer})`).join('\n')
                        );
                        if (peerIdToCall && connections.some(c => c.peer === peerIdToCall)) {
                          startVoiceCall(peerIdToCall);
                        } else if (peerIdToCall) {
                          console.log("App: Invalid peer ID for voice call:", peerIdToCall);
                          alert('ID inv√°lido ou contato n√£o conectado.');
                        }
                      }
                    }}
                    title="Iniciar chamada de voz"
                    disabled={connections.length === 0}
                  >
                    <i className="fas fa-phone button-icon"></i>
                  </button>
                  <button 
                    className="call-button"
                    onClick={() => {
                      if (isBroadcasting) {
                        stopBroadcast();
                      } else {
                        startBroadcast();
                      }
                    }}
                    title={isBroadcasting ? "Parar transmiss√£o de v√≠deo" : "Iniciar transmiss√£o de v√≠deo"}
                    disabled={connections.length === 0}
                    style={{ background: isBroadcasting ? '#ff0000' : '#4CAF50' }}
                  >
                    <i className={isBroadcasting ? "fas fa-stop button-icon" : "fas fa-video button-icon"}></i>
                  </button>
                </div>
              </div>
              
              <div className="user-info-container">
                {editingName ? (
                  renderNameForm()
                ) : (
                  <div style={{ display: 'flex', justifyContent: 'space-between', width: '100%' }}>
                    <span>Seu nome: <span className="username">{userName}</span></span>
                    <button onClick={() => setEditingName(true)} style={{ padding: '4px 8px' }}>
                      ‚úèÔ∏è Editar
                    </button>
                  </div>
                )}
              </div>
              
              <div className="peer-id-container">
                <span>Seu ID Fixo: <strong>{peerId || 'Gerando...'}</strong></span>
              </div>

              {(localStream || remoteStreams.filter(s => s.type === 'video').length > 0) && (
                <div className="video-container">
                  {localStream && (
                    <div>
                      <div className="video-label">Voc√™ ({userName})</div>
                      <video
                        className="video-player"
                        autoPlay
                        muted
                        ref={el => {
                          if (el) el.srcObject = localStream;
                        }}
                      />
                    </div>
                  )}
                  {remoteStreams.filter(s => s.type === 'video').map(({ peerId, stream }) => (
                    <div key={`video-${peerId}`}>
                      <div className="video-label">{getContactName(peerId)} ({peerId})</div>
                      <video
                        className="video-player"
                        autoPlay
                        ref={el => videoRefs.current[peerId] = el}
                      />
                    </div>
                  ))}
                </div>
              )}

              {remoteStreams.filter(s => s.type === 'voice').length > 0 && (
                <div className="audio-call-container">
                  <h3>Chamadas de Voz Ativas</h3>
                  {remoteStreams.filter(s => s.type === 'voice').map(({ peerId, stream }) => (
                    <div key={`voice-${peerId}`}>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <div>
                          <i className="fas fa-phone"></i> Chamada de voz com: <strong>{getContactName(peerId)}</strong>
                          <audio
                            ref={el => audioRefs.current[peerId] = el}
                            autoPlay
                            style={{ display: 'none' }}
                          />
                        </div>
                        <button 
                          onClick={() => endCall(peerId, 'voice')} 
                          className="call-end-button"
                        >
                          <i className="fas fa-phone-slash"></i> Encerrar
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {connections.length > 0 && (
                <div className="connected-peers">
                  <h3>Conex√µes Ativas: {connections.length}</h3>
                  {connections.map((conn, i) => (
                    <div key={i} className="peer-item">
                      {getContactName(conn.peer)}
                      {activeCalls.filter(c => c.peerId === conn.peer).map((call, callIndex) => (
                        <span key={callIndex} className="active-call-indicator">
                          <i className={call.type === 'voice' ? 'fas fa-phone' : 'fas fa-video'}></i> {call.type}
                        </span>
                      ))}
                    </div>
                  ))}
                </div>
              )}

              <div style={{ 
                height: '300px', 
                border: '1px solid #ddd',
                padding: '10px',
                overflowY: 'scroll',
                marginBottom: '10px'
              }}>
                {messages.map((msg, i) => (
                  <div 
                    key={i}
                    className={`message ${msg.sender === 'you' ? 'you' : 'other'}`}
                  >
                    <div className="message-header">
                      <span>{msg.senderName || (msg.sender === 'you' ? userName : getContactName(msg.sender))}</span>
                      <span style={{ fontSize: '0.8em', color: '#666' }}>{msg.time}</span>
                    </div>
                    {msg.type === 'text' ? (
                      msg.text
                    ) : msg.type === 'file' ? (
                      <div>
                        {msg.fileData ? (
                          <a
                            href={msg.fileData}
                            download={msg.fileName}
                            className="file-link"
                          >
                            {msg.fileName}
                          </a>
                        ) : (
                          <span>{msg.fileName}</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div 
                                className="progress" 
                                style={{ width: `${msg.progress}%` }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    ) : msg.type === 'audio' && (
                      <div>
                        {msg.audioData ? (
                          <audio 
                            controls 
                            src={msg.audioData}
                            className="audio-player"
                          />
                        ) : (
                          <span>√Åudio</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div 
                                className="progress" 
                                style={{ width: `${msg.progress}%` }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>

              <div className="file-input-container">
                <VoiceRecorder 
                  onRecordingComplete={handleAudioRecording}
                  disabled={connections.length === 0}
                />
                <button 
                  onClick={() => fileInputRef.current.click()}
                  disabled={connections.length === 0}
                  title="Enviar arquivo"
                >
                  <i className="fas fa-paperclip"></i>
                </button>
                <input
                  type="file"
                  ref={fileInputRef}
                  style={{ display: 'none' }}
                  onChange={handleFileChange}
                />
                <input
                  type="text"
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  placeholder="Digite sua mensagem..."
                  onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                  style={{ flex: 1, marginRight: '10px' }}
                />
                <button 
                  onClick={sendMessage} 
                  disabled={connections.length === 0 || !newMessage.trim()}
                  title="Enviar mensagem"
                >
                  <i className="fas fa-paper-plane"></i>
                </button>
              </div>
            </div>
          ) : (
            <ContactsScreen 
              contacts={contacts}
              setContacts={setContacts}
              onBack={() => setShowContacts(false)}
              onSelectContact={(peerId) => {
                console.log("App: Selecting contact:", peerId);
                connectToPeer(peerId);
                setShowContacts(false);
              }}
            />
          )}
        </div>
      );
    };

    console.log("Attempting to render React app");
    try {
      ReactDOM.render(
        <ErrorBoundary>
          <App />
        </ErrorBoundary>,
        document.getElementById('root')
      );
      console.log("React app rendered successfully");
    } catch (err) {
      console.error("Error rendering React app:", err);
      document.getElementById('root').innerHTML = `
        <div style="color: red; padding: 20px;">
          <h1>Erro ao carregar a aplica√ß√£o</h1>
          <p>${err.message}</p>
          <p>Verifique o console do navegador para mais detalhes.</p>
        </div>
      `;
    }
  </script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
