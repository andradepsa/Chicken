<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat P2P Distribuidor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    #root {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .peer-id-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .message {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    .message.you {
      background-color: #e3f2fd;
      margin-left: 20%;
    }
    .message.other {
      background-color: #f1f1f1;
      margin-right: 20%;
    }
    .file-link {
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .progress-container {
      margin-top: 5px;
    }
    .progress-bar {
      height: 5px;
      background: #ddd;
      border-radius: 3px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #4CAF50;
      width: 0%;
      transition: width 0.3s ease;
    }
    .connected-peers {
      margin-top: 10px;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .peer-item {
      margin: 5px 0;
      padding: 5px;
      background: #e3f2fd;
      border-radius: 3px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .voice-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .voice-button.recording {
      background: #ff0000;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .button-icon {
      color: white;
      font-size: 16px;
    }
    .audio-player {
      margin-top: 5px;
      width: 100%;
    }
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .contact-form-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .contact-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .contacts-list {
      max-height: 300px;
      overflow-y: auto;
      border-right: 4px solid #4CAF50;
      padding-right: 10px;
    }
    .id-backup-container {
      margin: 10px 0;
      padding: 10px;
      background-color: #fff3cd;
      border-radius: 4px;
      border: 1px solid #ffeeba;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    .id-input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 100px;
      margin-right: 10px;
    }
    .copy-button {
      background: #007bff;
    }
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status-online {
      background-color: #4CAF50;
    }
    .status-offline {
      background-color: #ff0000;
    }
    .status-connecting {
      background-color: #FFC107;
    }
    .distribution-stats {
      margin-top: 15px;
      padding: 10px;
      background-color: #e3f2fd;
      border-radius: 5px;
    }
    .message-source {
      font-size: 0.8em;
      color: #666;
      margin-top: 3px;
    }
    .call-type-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 11px;
      margin-left: 5px;
      background-color: #1976d2;
      color: white;
    }
    .debug-container {
      margin-top: 15px;
      padding: 10px;
      background-color: #e8f5e9;
      border-radius: 5px;
      border: 1px solid #c8e6c9;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const PEER_ID_STORAGE_KEY = 'p2pChatDistributorId';
    const DEFAULT_ID = 'AAAAAA';
    const HEARTBEAT_INTERVAL = 10000; // 10 segundos

    const usePersistentId = () => {
      const [peerId, setPeerId] = useState(() => {
        try {
          return localStorage.getItem(PEER_ID_STORAGE_KEY) || DEFAULT_ID;
        } catch (e) {
          return DEFAULT_ID;
        }
      });

      useEffect(() => {
        try {
          localStorage.setItem(PEER_ID_STORAGE_KEY, peerId);
          sessionStorage.setItem(PEER_ID_STORAGE_KEY, peerId);
          document.cookie = `${PEER_ID_STORAGE_KEY}=${peerId}; max-age=31536000; path=/`;
        } catch (e) {
          console.error("Erro ao persistir ID:", e);
        }
      }, [peerId]);

      return [peerId, setPeerId];
    };

    const IdBackupTools = ({ peerId, setPeerId, onSaveId, isConnected }) => {
      const [editableId, setEditableId] = useState(peerId);
      const [isEditing, setIsEditing] = useState(false);

      const copyToClipboard = () => {
        navigator.clipboard.writeText(peerId).then(() => {
          alert("ID copiado para a área de transferência!");
        });
      };

      const startEditing = () => {
        setEditableId(peerId);
        setIsEditing(true);
      };

      const saveId = () => {
        if (editableId.trim() === '') {
          alert("O ID não pode estar vazio!");
          return;
        }
        
        if (editableId !== peerId) {
          setPeerId(editableId);
          if (onSaveId) onSaveId(editableId);
        }
        
        setIsEditing(false);
      };

      return (
        <div className="id-backup-container">
          <div>
            <strong>Distributor ID:</strong> 
            {isEditing ? (
              <>
                <input 
                  type="text" 
                  className="id-input"
                  value={editableId}
                  onChange={(e) => setEditableId(e.target.value)}
                  placeholder="Insira o ID"
                />
                <button onClick={saveId}>Salvar</button>
                <button onClick={() => setIsEditing(false)}>Cancelar</button>
              </>
            ) : (
              <>
                {peerId}
                <button onClick={copyToClipboard} className="copy-button">
                  Copiar
                </button>
                <button 
                  onClick={startEditing}
                  disabled={isConnected}
                >
                  Editar
                </button>
              </>
            )}
          </div>
          {isConnected && !isEditing && (
            <p><small>Log out to edit ID</small></p>
          )}
        </div>
      );
    };

    const CallDebugInfo = ({ activeCalls }) => {
      const renderCallInfo = (peerId, calls) => {
        return (
          <div key={peerId} style={{ margin: '5px 0', padding: '5px', backgroundColor: '#f0f0f0', borderRadius: '4px' }}>
            <div><strong>Peer ID:</strong> {peerId}</div>
            {calls.map((callData, index) => (
              <div key={index} style={{ marginLeft: '10px', borderLeft: '2px solid #ccc', paddingLeft: '10px', marginTop: '5px' }}>
                <div>
                  <strong>Tipo:</strong> {callData.type} | 
                  <strong>Tracks:</strong> {callData.stream?.getTracks().length || 0} (
                  Áudio: {callData.stream?.getAudioTracks().length || 0}, 
                  Vídeo: {callData.stream?.getVideoTracks().length || 0})
                </div>
                <div>
                  <strong>Redistribuições:</strong> {callData.redistributedCalls.size}
                  {callData.redistributedCalls.size > 0 && (
                    <div style={{ marginLeft: '10px' }}>
                      {Array.from(callData.redistributedCalls.keys()).map(redistPeerId => (
                        <div key={redistPeerId}>→ {redistPeerId}</div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      };

      return (
        <div className="debug-container">
          <h3>Informações de Depuração de Chamadas</h3>
          {Object.entries(activeCalls).length === 0 ? (
            <p>Nenhuma chamada ativa</p>
          ) : (
            Object.entries(activeCalls).map(([peerId, calls]) => renderCallInfo(peerId, calls))
          )}
        </div>
      );
    };

    const DistributorApp = () => {
      const [peerId, setPeerId] = usePersistentId();
      const [connections, setConnections] = useState([]);
      const [messages, setMessages] = useState([]);
      const [connectionStatus, setConnectionStatus] = useState('desconectado');
      const [stats, setStats] = useState({
        messagesReceived: 0,
        messagesDistributed: 0,
        callsReceived: 0,
        callsDistributed: 0,
        voiceCallsReceived: 0,
        voiceCallsDistributed: 0,
        activeConnections: 0
      });
      
      const peerInstance = useRef(null);
      const pendingFiles = useRef({});
      const messagesEndRef = useRef(null);
      const activeConnectionsRef = useRef(new Map());
      const activeCallsRef = useRef(new Map());
      const messageCache = useRef(new Set());
      const processedMessages = useRef(new Map());
      const CHUNK_SIZE = 16 * 1024;

      useEffect(() => {
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
      }, [messages]);

      useEffect(() => {
        const interval = setInterval(() => {
          const now = Date.now();
          processedMessages.current.forEach((timestamp, id) => {
            if (now - timestamp > 5 * 60 * 1000) {
              processedMessages.current.delete(id);
            }
          });
        }, 60000);
        return () => clearInterval(interval);
      }, []);

      const toggleConnection = () => {
        if (connectionStatus === 'conectado' || connectionStatus === 'conectando') {
          disconnectPeer();
        } else {
          setupPeer();
        }
      };

      const disconnectPeer = () => {
        if (peerInstance.current) {
          try {
            console.log("Desconectando peer...");
            activeCallsRef.current.forEach((calls, peerId) => {
              calls.forEach(callData => {
                try {
                  if (callData.call && typeof callData.call.close === 'function') {
                    callData.call.close();
                  }
                  callData.redistributedCalls.forEach(redistCall => {
                    if (redistCall && typeof redistCall.close === 'function') {
                      redistCall.close();
                    }
                  });
                  console.log(`Chamada com ${peerId} encerrada`);
                } catch (e) {
                  console.error(`Erro ao encerrar chamada com ${peerId}:`, e);
                }
              });
            });
            activeCallsRef.current.clear();
            activeConnectionsRef.current.forEach((conn, connPeerId) => {
              try {
                if (conn && typeof conn.close === 'function') {
                  conn.close();
                }
              } catch (e) {
                console.error(`Erro ao fechar conexão com ${connPeerId}:`, e);
              }
            });
            activeConnectionsRef.current.clear();
            setConnections([]);
            messageCache.current.clear();
            processedMessages.current.clear();
            if (peerInstance.current && typeof peerInstance.current.destroy === 'function') {
              peerInstance.current.destroy();
            }
            peerInstance.current = null;
            setConnectionStatus('desconectado');
            setStats({
              messagesReceived: 0,
              messagesDistributed: 0,
              callsReceived: 0,
              callsDistributed: 0,
              voiceCallsReceived: 0,
              voiceCallsDistributed: 0,
              activeConnections: 0
            });
            console.log("Peer desconectado com sucesso");
          } catch (err) {
            console.error("Erro ao desconectar peer:", err);
            peerInstance.current = null;
            activeConnectionsRef.current.clear();
            activeCallsRef.current.clear();
            setConnectionStatus('desconectado');
            setConnections([]);
          }
        }
      };

      const setupPeer = () => {
        if (!peerId) return;
        console.log("Configurando distribuidor com ID:", peerId);
        setConnectionStatus('conectando');
        
        if (peerInstance.current) {
          try {
            peerInstance.current.destroy();
          } catch (err) {
            console.error("Erro ao destruir instância anterior:", err);
          }
        }
        
        const peer = new Peer(peerId, {
          host: '0.peerjs.com',
          port: 443,
          secure: true,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
              { urls: 'stun:stun4.l.google.com:19302' }
            ]
          },
          debug: 2,
          pingInterval: 5000,
          retryMaxAttempts: 10
        });

        peer.on('open', (id) => {
          console.log("Distribuidor conectado com ID:", id);
          setConnectionStatus('conectado');
          startHeartbeat();
        });

        peer.on('connection', (conn) => {
          console.log("Nova conexão recebida de:", conn.peer);
          setupConnection(conn);
          setTimeout(() => {
            redistributeExistingCallsToNewPeer(conn.peer);
          }, 1000);
        });

        peer.on('call', (call) => {
          const callType = call.metadata && call.metadata.type === 'voice' ? 'voice' : 'video';
          console.log(`Chamada de ${callType} recebida de ${call.peer}`);
          
          if (callType === 'voice') {
            setStats(prev => ({
              ...prev,
              voiceCallsReceived: prev.voiceCallsReceived + 1
            }));
          } else {
            setStats(prev => ({
              ...prev,
              callsReceived: prev.callsReceived + 1
            }));
          }

          const emptyStream = new MediaStream();
          call.answer(emptyStream);

          call.on('stream', (remoteStream) => {
            console.log(`Recebido stream de ${call.peer} (${callType}) com ${remoteStream.getAudioTracks().length} trilhas de áudio e ${remoteStream.getVideoTracks().length} trilhas de vídeo`);
            const hasValidTracks = 
              (callType === 'voice' && remoteStream.getAudioTracks().length > 0) ||
              (callType === 'video' && remoteStream.getTracks().length > 0);
            if (!hasValidTracks) {
              console.warn(`Stream recebido de ${call.peer} não tem trilhas válidas para ${callType}`);
              call.close();
              return;
            }
            handleIncomingMediaStream(call, remoteStream, callType);
          });

          call.on('close', () => {
            console.log(`Chamada de ${callType} com ${call.peer} encerrada`);
            cleanupCallsForPeer(call.peer, call);
          });

          call.on('error', (err) => {
            console.error(`Erro na chamada de ${callType} com ${call.peer}:`, err);
            cleanupCallsForPeer(call.peer, call);
          });
        });

        peer.on('error', (err) => {
          console.error("Erro no peer:", err);
          setConnectionStatus('erro');
          if (err.type === 'network' || err.type === 'peer-unavailable') {
            console.log("Erro de rede ou peer indisponível, tentando reconectar...");
            setTimeout(() => {
              if (peerInstance.current && peerInstance.current.disconnected) {
                try {
                  peerInstance.current.reconnect();
                } catch (e) {
                  console.error("Falha na reconexão:", e);
                }
              }
            }, 5000);
          }
        });

        peer.on('disconnected', () => {
          console.log("Peer desconectado");
          setConnectionStatus('desconectado');
          setTimeout(() => {
            if (peerInstance.current && peerInstance.current.disconnected) {
              try {
                console.log("Tentando reconectar após desconexão...");
                peerInstance.current.reconnect();
              } catch (e) {
                console.error("Falha na reconexão após desconexão:", e);
              }
            }
          }, 3000);
        });

        peerInstance.current = peer;
      };

      const handleIncomingMediaStream = (call, remoteStream, callType) => {
        if (!activeCallsRef.current.has(call.peer)) {
          activeCallsRef.current.set(call.peer, []);
        }
        const calls = activeCallsRef.current.get(call.peer);
        let existingCallData = calls.find(c => c.type === callType);
        
        if (existingCallData) {
          updateExistingCall(existingCallData, remoteStream);
        } else {
          createNewCallEntry(call, remoteStream, callType);
        }
        setConnections(Array.from(activeConnectionsRef.current.keys()));
      };

      const updateExistingCall = (callData, newStream) => {
        console.log(`Atualizando stream existente de ${callData.type}`);
        callData.stream = newStream;
        callData.redistributedCalls.forEach((redistCall, peerId) => {
          updateRedistributedCall(callData, peerId, redistCall);
        });
      };

      const updateRedistributedCall = (callData, peerId, oldRedistCall) => {
        try {
          if (!callData.stream || callData.stream.getTracks().length === 0) {
            console.warn(`Stream original inválido ao atualizar redistribuição para ${peerId}`);
            callData.redistributedCalls.delete(peerId);
            return;
          }

          const newRedistStream = new MediaStream();
          console.log(`Atualizando stream redistribuído para ${peerId}`);

          callData.stream.getTracks().forEach(track => {
            if (track.enabled && track.readyState === 'live') {
              console.log(`Adicionando track ${track.kind} (${track.id}) ao stream redistribuído atualizado`);
              newRedistStream.addTrack(track.clone());
            } else {
              console.warn(`Track ${track.kind} (${track.id}) não está ativo (enabled=${track.enabled}, readyState=${track.readyState}), ignorando`);
            }
          });

          if (newRedistStream.getTracks().length === 0) {
            console.warn(`Stream redistribuído atualizado para ${peerId} não contém trilhas válidas`);
            callData.redistributedCalls.delete(peerId);
            return;
          }

          if (oldRedistCall && typeof oldRedistCall.close === 'function') {
            try {
              oldRedistCall.close();
              console.log(`Chamada redistribuída antiga para ${peerId} fechada`);
            } catch (e) {
              console.error(`Erro ao fechar chamada redistribuída antiga para ${peerId}:`, e);
            }
          }

          if (!peerInstance.current || !activeConnectionsRef.current.has(peerId)) {
            console.log(`Peer ${peerId} não está mais conectado, cancelando atualização de redistribuição`);
            callData.redistributedCalls.delete(peerId);
            return;
          }

          const newRedistCall = peerInstance.current.call(peerId, newRedistStream, {
            metadata: { type: callData.type, original: callData.call.peer }
          });

          callData.redistributedCalls.set(peerId, newRedistCall);
          setupRedistributedCallHandlers(newRedistCall, peerId, callData);

          console.log(`Chamada de ${callData.type} redistribuída atualizada para ${peerId}`);
        } catch (err) {
          console.error(`Erro ao atualizar redistribuição para ${peerId}:`, err);
          callData.redistributedCalls.delete(peerId);
        }
      };

      const createNewCallEntry = (call, stream, callType) => {
        console.log(`Criando nova entrada de chamada de ${callType} de ${call.peer}`);
        const callData = { 
          call, 
          stream, 
          redistributedCalls: new Map(),
          type: callType
        };
        activeCallsRef.current.get(call.peer).push(callData);
        redistributeCallToAllPeers(callData);
      };

      const redistributeCallToAllPeers = (callData) => {
        console.log(`Redistribuindo chamada de ${callData.type} de ${callData.call.peer} para todos os peers`);
        console.log(`Peers conectados: ${Array.from(activeConnectionsRef.current.keys()).join(', ')}`);

        if (!peerInstance.current || peerInstance.current.destroyed) {
          console.warn('Peer instance não está ativa, abortando redistribuição');
          return;
        }

        activeConnectionsRef.current.forEach((conn, peerId) => {
          if (peerId !== callData.call.peer) {
            if (conn.open) {
              console.log(`Tentando redistribuir para ${peerId}`);
              redistributeCallToPeer(callData, peerId);
            } else {
              console.warn(`Conexão com ${peerId} não está aberta, pulando redistribuição`);
            }
          }
        });

        setStats(prev => ({
          ...prev,
          [callData.type === 'voice' ? 'voiceCallsDistributed' : 'callsDistributed']:
            prev[callData.type === 'voice' ? 'voiceCallsDistributed' : 'callsDistributed'] + activeConnectionsRef.current.size - 1
        }));
      };

      const redistributeCallToPeer = (callData, peerId) => {
        try {
          if (callData.redistributedCalls.has(peerId)) {
            console.log(`Já existe redistribuição de ${callData.type} para ${peerId}, verificando necessidade de atualização`);
            const existingCall = callData.redistributedCalls.get(peerId);
            if (existingCall && typeof existingCall.close !== 'function') {
              console.warn(`Chamada existente para ${peerId} é inválida, limpando`);
              callData.redistributedCalls.delete(peerId);
            } else {
              updateRedistributedCall(callData, peerId, existingCall);
              return;
            }
          }

          console.log(`Iniciando redistribuição de chamada de ${callData.type} para ${peerId}`);

          if (!callData.stream || callData.stream.getTracks().length === 0) {
            console.warn(`Sem stream válido para redistribuir chamada de ${callData.call.peer} para ${peerId}`);
            return;
          }

          const redistributedStream = new MediaStream();
          console.log(`Criando novo stream para redistribuir de ${callData.call.peer} para ${peerId}`);

          console.log(`Stream original tem ${callData.stream.getTracks().length} tracks: Video=${callData.stream.getVideoTracks().length}, Audio=${callData.stream.getAudioTracks().length}`);
          
          callData.stream.getTracks().forEach(track => {
            if (track.enabled && track.readyState === 'live') {
              console.log(`Adicionando track ${track.kind} (${track.id}, enabled=${track.enabled}) ao stream redistribuído`);
              const clonedTrack = track.clone();
              redistributedStream.addTrack(clonedTrack);
            } else {
              console.warn(`Track ${track.kind} (${track.id}) não está ativo (enabled=${track.enabled}, readyState=${track.readyState}), ignorando`);
            }
          });

          if (redistributedStream.getTracks().length === 0) {
            console.warn(`Stream redistribuído para ${peerId} não contém trilhas válidas`);
            return;
          }

          console.log(`Stream redistribuído tem ${redistributedStream.getTracks().length} tracks: Video=${redistributedStream.getVideoTracks().length}, Audio=${redistributedStream.getAudioTracks().length}`);

          if (!peerInstance.current || peerInstance.current.destroyed) {
            console.warn(`Peer instance não está ativa para criar chamada para ${peerId}`);
            return;
          }

          const redistCall = peerInstance.current.call(peerId, redistributedStream, {
            metadata: { type: callData.type, original: callData.call.peer }
          });

          callData.redistributedCalls.set(peerId, redistCall);
          setupRedistributedCallHandlers(redistCall, peerId, callData);

          console.log(`Chamada de ${callData.type} redistribuída com sucesso para ${peerId}`);
        } catch (err) {
          console.error(`Erro ao redistribuir chamada de ${callData.type} para ${peerId}:`, err);
          callData.redistributedCalls.delete(peerId);
        }
      };

      const setupRedistributedCallHandlers = (redistCall, peerId, callData) => {
        redistCall.on('stream', (clientRemoteStream) => {
          console.log(`Recebido stream de resposta de ${peerId} durante redistribuição de ${callData.type}`);
        });

        redistCall.on('close', () => {
          console.log(`Chamada de ${callData.type} redistribuída para ${peerId} encerrada`);
          callData.redistributedCalls.delete(peerId);
        });

        redistCall.on('error', (err) => {
          console.error(`Erro na chamada de ${callData.type} redistribuída para ${peerId}:`, err);
          callData.redistributedCalls.delete(peerId);
        });
      };

      const redistributeExistingCallsToNewPeer = (newPeerId) => {
        console.log(`Redistribuindo chamadas existentes para novo peer ${newPeerId}`);
        activeCallsRef.current.forEach((calls, originPeerId) => {
          if (originPeerId !== newPeerId) {
            calls.forEach(callData => {
              redistributeCallToPeer(callData, newPeerId);
            });
          }
        });
      };

      const cleanupCallsForPeer = (peerId, specificCall = null) => {
        if (activeCallsRef.current.has(peerId)) {
          const calls = activeCallsRef.current.get(peerId);
          if (specificCall) {
            const callIndex = calls.findIndex(c => c.call === specificCall);
            if (callIndex !== -1) {
              const callData = calls[callIndex];
              callData.redistributedCalls.forEach((redistCall, redistPeerId) => {
                try {
                  redistCall.close();
                  console.log(`Fechada chamada redistribuída para ${redistPeerId}`);
                } catch (e) {
                  console.error(`Erro ao fechar redistribuição para ${redistPeerId}:`, e);
                }
              });
              callData.redistributedCalls.clear();
              if (callData.stream) {
                callData.stream.getTracks().forEach(track => {
                  track.stop();
                  console.log(`Track ${track.kind} parado para chamada de ${peerId}`);
                });
              }
              calls.splice(callIndex, 1);
            }
          } else {
            calls.forEach(callData => {
              try {
                if (callData.call && typeof callData.call.close === 'function') {
                  callData.call.close();
                }
              } catch (e) {
                console.error(`Erro ao fechar chamada com ${peerId}:`, e);
              }
              callData.redistributedCalls.forEach((redistCall, redistPeerId) => {
                try {
                  redistCall.close();
                } catch (e) {
                  console.error(`Erro ao fechar redistribuição para ${redistPeerId}:`, e);
                }
              });
              callData.redistributedCalls.clear();
              if (callData.stream) {
                callData.stream.getTracks().forEach(track => {
                  track.stop();
                  console.log(`Track ${track.kind} parado para chamada de ${peerId}`);
                });
              }
            });
            activeCallsRef.current.delete(peerId);
          }
          if (calls.length === 0) {
            activeCallsRef.current.delete(peerId);
          }
        }
      };

      const startHeartbeat = () => {
        const heartbeatInterval = setInterval(() => {
          if (!peerInstance.current || connectionStatus !== 'conectado') {
            clearInterval(heartbeatInterval);
            return;
          }
          activeConnectionsRef.current.forEach((conn, peerId) => {
            if (conn.open === false) {
              console.log(`Conexão com ${peerId} fechada, removendo...`);
              activeConnectionsRef.current.delete(peerId);
              setConnections(Array.from(activeConnectionsRef.current.keys()));
              cleanupCallsForPeer(peerId);
            } else {
              try {
                conn.send({ type: 'heartbeat', timestamp: Date.now() });
              } catch (e) {
                console.error(`Erro ao enviar heartbeat para ${peerId}:`, e);
                activeConnectionsRef.current.delete(peerId);
                setConnections(Array.from(activeConnectionsRef.current.keys()));
                cleanupCallsForPeer(peerId);
              }
            }
          });
          setStats(prev => ({
            ...prev,
            activeConnections: activeConnectionsRef.current.size
          }));
          activeCallsRef.current.forEach((calls, originPeerId) => {
            if (!activeConnectionsRef.current.has(originPeerId)) {
              console.log(`Originador ${originPeerId} não está conectado, mantendo chamadas temporariamente`);
            }
            calls.forEach(callData => {
              activeConnectionsRef.current.forEach((conn, peerId) => {
                if (peerId !== originPeerId && !callData.redistributedCalls.has(peerId)) {
                  console.log(`Redistribuindo chamada ${callData.type} para novo peer ${peerId}`);
                  redistributeCallToPeer(callData, peerId);
                }
              });
            });
          });
        }, HEARTBEAT_INTERVAL);
      };

      useEffect(() => {
        if (connectionStatus !== 'conectado' && connectionStatus !== 'conectando') return;
        const checkConnectionInterval = setInterval(() => {
          if (peerInstance.current && peerInstance.current.disconnected) {
            console.log("Tentando reconectar...");
            try {
              peerInstance.current.reconnect();
            } catch (e) {
              console.error("Falha na reconexão, recriando peer:", e);
              setupPeer();
            }
          }
        }, 30000);
        return () => clearInterval(checkConnectionInterval);
      }, [connectionStatus]);

      const handleIdChange = (newId) => {
        disconnectPeer();
      };

      const handleIncomingData = (data, sourceConn) => {
        console.log(`Recebendo dados de ${sourceConn.peer}:`, data);
        if (data.type === 'heartbeat') return;
        if (data.id && processedMessages.current.has(data.id)) {
          console.log(`Mensagem ${data.id} já processada, ignorando`);
          return;
        }
        if (data.id) processedMessages.current.set(data.id, Date.now());
        setStats(prev => ({
          ...prev,
          messagesReceived: prev.messagesReceived + 1
        }));
        if (data.type === 'message') {
          const newMessage = {
            id: data.id || (Date.now() + Math.random().toString(36).substring(7)),
            text: data.text,
            sender: data.senderName || sourceConn.peer,
            timestamp: new Date().toISOString(),
            source: sourceConn.peer
          };
          setMessages(prev => [...prev, newMessage]);
          if (!data.id) data.id = newMessage.id;
          distributeMessage(data, sourceConn.peer);
        } else if (data.type === 'file-start' || data.type === 'file-chunk' || 
                   data.type === 'audio-start' || data.type === 'audio-chunk') {
          console.log(`${data.type} recebido, redistribuindo...`);
          distributeMessage(data, sourceConn.peer);
        }
      };

      const distributeMessage = (data, sourceId) => {
        let distributionCount = 0;
        if (!data.id) {
          data.id = Date.now() + Math.random().toString(36).substring(7);
          processedMessages.current.set(data.id, Date.now());
        }
        activeConnectionsRef.current.forEach((conn, peerId) => {
          if (peerId !== sourceId) {
            try {
              if (conn.open) {
                console.log(`Distribuindo mensagem ${data.id} para ${peerId}`);
                conn.send(data);
                distributionCount++;
              } else {
                console.warn(`Conexão com ${peerId} não está aberta, não foi possível distribuir`);
              }
            } catch (err) {
              console.error(`Erro ao enviar para ${peerId}:`, err);
              activeConnectionsRef.current.delete(peerId);
              setConnections(Array.from(activeConnectionsRef.current.keys()));
            }
          }
        });
        setStats(prev => ({
          ...prev,
          messagesDistributed: prev.messagesDistributed + distributionCount
        }));
        console.log(`Mensagem ${data.id} distribuída para ${distributionCount} conexões`);
      };

      const setupConnection = (conn) => {
        if (activeConnectionsRef.current.has(conn.peer)) {
          console.log(`Conexão com ${conn.peer} já existe, fechando a anterior`);
          try {
            const existingConn = activeConnectionsRef.current.get(conn.peer);
            if (existingConn && existingConn.open) {
              existingConn.close();
            }
          } catch (e) {
            console.error(`Erro ao fechar conexão existente com ${conn.peer}:`, e);
          }
        }

        // Adicionar timeout para conexões que não se abrem
        const connectionTimeout = setTimeout(() => {
          if (!conn.open) {
            console.warn(`Timeout: Conexão com ${conn.peer} não foi estabelecida em 10 segundos`);
            conn.close();
            activeConnectionsRef.current.delete(conn.peer);
            setConnections(Array.from(activeConnectionsRef.current.keys()));
            setStats(prev => ({
              ...prev,
              activeConnections: activeConnectionsRef.current.size
            }));
          }
        }, 10000);

        conn.on('open', () => {
          clearTimeout(connectionTimeout);
          console.log(`Conexão estabelecida com ${conn.peer}`);
          activeConnectionsRef.current.set(conn.peer, conn);
          setConnections(Array.from(activeConnectionsRef.current.keys()));
          setStats(prev => ({
            ...prev,
            activeConnections: activeConnectionsRef.current.size
          }));
        });

        conn.on('data', (data) => {
          handleIncomingData(data, conn);
        });

        conn.on('close', () => {
          clearTimeout(connectionTimeout);
          console.log(`Conexão fechada com ${conn.peer}`);
          activeConnectionsRef.current.delete(conn.peer);
          setConnections(Array.from(activeConnectionsRef.current.keys()));
          setStats(prev => ({
            ...prev,
            activeConnections: activeConnectionsRef.current.size
          }));
          cleanupCallsForPeer(conn.peer);
        });

        conn.on('error', (err) => {
          clearTimeout(connectionTimeout);
          console.error(`Erro na conexão com ${conn.peer}:`, err);
          activeConnectionsRef.current.delete(conn.peer);
          setConnections(Array.from(activeConnectionsRef.current.keys()));
          setStats(prev => ({
            ...prev,
            activeConnections: activeConnectionsRef.current.size
          }));
          cleanupCallsForPeer(conn.peer);
        });
      };

      return (
        <div>
          <h1>P2P Message Distributor</h1>
          <p>The ID consists of 6 alphanumeric characters.</p>
          <p>More specifically:</p>
          <p>Letters: A to Z (uppercase and lowercase)</p>
          <p>Numbers: 0 to 9</p>    
          <div className="peer-id-container">
            <div>
              <span 
                className={`status-indicator status-${
                  connectionStatus === 'conectado' ? 'online' : 
                  connectionStatus === 'conectando' ? 'connecting' : 'offline'
                }`}
              ></span>
              Status: {connectionStatus}
              <button onClick={toggleConnection}>
                {connectionStatus === 'conectado' || connectionStatus === 'conectando' ? 'Desconectar' : 'Conectar'}
              </button>
            </div>
          </div>
          
          <IdBackupTools 
            peerId={peerId} 
            setPeerId={setPeerId} 
            onSaveId={handleIdChange} 
            isConnected={connectionStatus === 'conectado' || connectionStatus === 'conectando'}
          />
          
          <div className="distribution-stats">
            <h3>Distribution Statistics</h3>
            <p>Messages received: {stats.messagesReceived}</p>
            <p>Distributed messages: {stats.messagesDistributed}</p>
            <p>Video calls received: {stats.callsReceived}</p>
            <p>Distributed video calls: {stats.callsDistributed}</p>
            <p>Voice calls received: {stats.voiceCallsReceived}</p>
            <p>Distributed voice calls: {stats.voiceCallsDistributed}</p>
            <p>Active connections: {stats.activeConnections}</p>
          </div>
          
          <div className="connected-peers">
            <h3>Active Connections ({connections.length})</h3>
            {connections.length === 0 ? (
              <p>No active connections</p>
            ) : (
              <div>
                {connections.map((peerId, index) => (
                  <div key={index} className="peer-item">
                    <span className="status-indicator status-online"></span>
                    {peerId}
                    {activeCallsRef.current.has(peerId) && activeCallsRef.current.get(peerId).map((callData, callIndex) => (
                      <span key={callIndex} className="call-type-badge">
                        {callData.type === 'voice' ? 'Voice' : 'Video'}
                      </span>
                    ))}
                  </div>
                ))}
              </div>
            )}
          </div>

          <div style={{ marginTop: '20px' }}>
            <h3>Messages</h3>
            <div style={{ maxHeight: '300px', overflowY: 'auto', border: '1px solid #ddd', padding: '10px' }}>
              {messages.length === 0 ? (
                <p>Nenhuma mensagem recebida</p>
              ) : (
                <div>
                  {messages.map((msg, index) => (
                    <div key={index} className={`message other`}>
                      <strong>{msg.sender || msg.source}:</strong> {msg.text}
                      <div className="message-source">
                        Origem: {msg.source} | {new Date(msg.timestamp).toLocaleTimeString()}
                      </div>
                    </div>
                  ))}
                  <div ref={messagesEndRef} />
                </div>
              )}
            </div>
          </div>

          <CallDebugInfo activeCalls={Object.fromEntries(activeCallsRef.current)} />
        </div>
      );
    };

    ReactDOM.render(<DistributorApp />, document.getElementById('root'));
  </script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
