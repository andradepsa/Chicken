<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat P2P Distribuidor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    #root {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .peer-id-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .message {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    .message.you {
      background-color: #e3f2fd;
      margin-left: 20%;
    }
    .message.other {
      background-color: #f1f1f1;
      margin-right: 20%;
    }
    .file-link {
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .progress-container {
      margin-top: 5px;
    }
    .progress-bar {
      height: 5px;
      background: #ddd;
      border-radius: 3px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #4CAF50;
      width: 0%;
      transition: width 0.3s ease;
    }
    .connected-peers {
      margin-top: 10px;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .peer-item {
      margin: 5px 0;
      padding: 5px;
      background: #e3f2fd;
      border-radius: 3px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .voice-button {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .voice-button.recording {
      background: #ff0000;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .button-icon {
      color: white;
      font-size: 16px;
    }
    .audio-player {
      margin-top: 5px;
      width: 100%;
    }
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .contact-form-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .contact-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .contacts-list {
      max-height: 300px;
      overflow-y: auto;
      border-right: 4px solid #4CAF50;
      padding-right: 10px;
    }
    .id-backup-container {
      margin: 10px 0;
      padding: 10px;
      background-color: #fff3cd;
      border-radius: 4px;
      border: 1px solid #ffeeba;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    .id-input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 100px;
      margin-right: 10px;
    }
    .copy-button {
      background: #007bff;
    }
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status-online {
      background-color: #4CAF50;
    }
    .status-offline {
      background-color: #ff0000;
    }
    .status-connecting {
      background-color: #FFC107;
    }
    .distribution-stats {
      margin-top: 15px;
      padding: 10px;
      background-color: #e3f2fd;
      border-radius: 5px;
    }
    .message-source {
      font-size: 0.8em;
      color: #666;
      margin-top: 3px;
    }
    .call-type-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 11px;
      margin-left: 5px;
      background-color: #1976d2;
      color: white;
    }
    .debug-container {
      margin-top: 15px;
      padding: 10px;
      background-color: #e8f5e9;
      border-radius: 5px;
      border: 1px solid #c8e6c9;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const PEER_ID_STORAGE_KEY = 'p2pChatDistributorId';
    const DEFAULT_ID = 'AAAAAA';

    const usePersistentId = () => {
      const [peerId, setPeerId] = useState(() => {
        try {
          return localStorage.getItem(PEER_ID_STORAGE_KEY) || DEFAULT_ID;
        } catch (e) {
          return DEFAULT_ID;
        }
      });

      useEffect(() => {
        try {
          localStorage.setItem(PEER_ID_STORAGE_KEY, peerId);
          sessionStorage.setItem(PEER_ID_STORAGE_KEY, peerId);
          document.cookie = `${PEER_ID_STORAGE_KEY}=${peerId}; max-age=31536000; path=/`;
        } catch (e) {
          console.error("Erro ao persistir ID:", e);
        }
      }, [peerId]);

      return [peerId, setPeerId];
    };

    const IdBackupTools = ({ peerId, setPeerId, onSaveId, isConnected }) => {
      const [editableId, setEditableId] = useState(peerId);
      const [isEditing, setIsEditing] = useState(false);

      const copyToClipboard = () => {
        navigator.clipboard.writeText(peerId).then(() => {
          alert("ID copiado para a área de transferência!");
        });
      };

      const startEditing = () => {
        setEditableId(peerId);
        setIsEditing(true);
      };

      const saveId = () => {
        if (editableId.trim() === '') {
          alert("O ID não pode estar vazio!");
          return;
        }
        
        if (editableId !== peerId) {
          setPeerId(editableId);
          if (onSaveId) onSaveId(editableId);
        }
        
        setIsEditing(false);
      };

      return (
        <div className="id-backup-container">
          <div>
            <strong>Distributor ID:</strong> 
            {isEditing ? (
              <>
                <input 
                  type="text" 
                  className="id-input"
                  value={editableId}
                  onChange={(e) => setEditableId(e.target.value)}
                  placeholder="Insira o ID"
                />
                <button onClick={saveId}>Salvar</button>
                <button onClick={() => setIsEditing(false)}>Cancelar</button>
              </>
            ) : (
              <>
                {peerId}
                <button onClick={copyToClipboard} className="copy-button">
                  Copiar
                </button>
                <button 
                  onClick={startEditing}
                  disabled={isConnected}
                >
                  Editar
                </button>
              </>
            )}
          </div>
          {isConnected && !isEditing && (
            <p><small>Log out to edit ID</small></p>
          )}
        </div>
      );
    };

    const CallDebugInfo = ({ activeCalls }) => {
      const renderCallInfo = (peerId, calls) => {
        return (
          <div key={peerId} style={{ margin: '5px 0', padding: '5px', backgroundColor: '#f0f0f0', borderRadius: '4px' }}>
            <div><strong>Peer ID:</strong> {peerId}</div>
            {calls.map((callData, index) => (
              <div key={index} style={{ marginLeft: '10px', borderLeft: '2px solid #ccc', paddingLeft: '10px', marginTop: '5px' }}>
                <div>
                  <strong>Tipo:</strong> {callData.type} | 
                  <strong>Tracks:</strong> {callData.stream?.getTracks().length || 0} (
                  Áudio: {callData.stream?.getAudioTracks().length || 0}, 
                  Vídeo: {callData.stream?.getVideoTracks().length || 0})
                </div>
                <div>
                  <strong>Redistribuições:</strong> {callData.redistributedCalls.size}
                  {callData.redistributedCalls.size > 0 && (
                    <div style={{ marginLeft: '10px' }}>
                      {Array.from(callData.redistributedCalls.keys()).map(redistPeerId => (
                        <div key={redistPeerId}>→ {redistPeerId}</div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      };

      return (
        <div className="debug-container">
          <h3>Informações de Depuração de Chamadas</h3>
          {Object.entries(activeCalls).length === 0 ? (
            <p>Nenhuma chamada ativa</p>
          ) : (
            Object.entries(activeCalls).map(([peerId, calls]) => renderCallInfo(peerId, calls))
          )}
        </div>
      );
    };

    const DistributorApp = () => {
      const [peerId, setPeerId] = usePersistentId();
      const [connections, setConnections] = useState([]);
      const [messages, setMessages] = useState([]);
      const [connectionStatus, setConnectionStatus] = useState('desconectado');
      const [stats, setStats] = useState({
        messagesReceived: 0,
        messagesDistributed: 0,
        callsReceived: 0,
        callsDistributed: 0,
        voiceCallsReceived: 0,
        voiceCallsDistributed: 0,
        activeConnections: 0
      });
      
      const peerInstance = useRef(null);
      const pendingFiles = useRef({});
      const messagesEndRef = useRef(null);
      const activeConnectionsRef = useRef(new Map());
      const activeCallsRef = useRef(new Map()); // Mapa de chamadas ativas: peerId -> [{ call, stream, redistributedCalls, type }, ...]
      const CHUNK_SIZE = 16 * 1024;

      useEffect(() => {
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
      }, [messages]);

      const toggleConnection = () => {
        if (connectionStatus === 'conectado' || connectionStatus === 'conectando') {
          disconnectPeer();
        } else {
          setupPeer();
        }
      };

      const disconnectPeer = () => {
        if (peerInstance.current) {
          try {
            console.log("Desconectando peer...");
            
            activeCallsRef.current.forEach((calls, peerId) => {
              calls.forEach(callData => {
                try {
                  callData.call.close();
                  callData.redistributedCalls.forEach(redistCall => redistCall.close());
                  console.log(`Chamada com ${peerId} encerrada`);
                } catch (e) {
                  console.error(`Erro ao encerrar chamada com ${peerId}:`, e);
                }
              });
            });
            activeCallsRef.current.clear();
            
            activeConnectionsRef.current.forEach((conn) => {
              try {
                conn.close();
              } catch (e) {
                console.error("Erro ao fechar conexão:", e);
              }
            });
            
            activeConnectionsRef.current.clear();
            setConnections([]);
            
            peerInstance.current.destroy();
            peerInstance.current = null;
            
            setConnectionStatus('desconectado');
            
            setStats({
              messagesReceived: 0,
              messagesDistributed: 0,
              callsReceived: 0,
              callsDistributed: 0,
              voiceCallsReceived: 0,
              voiceCallsDistributed: 0,
              activeConnections: 0
            });
            
            console.log("Peer desconectado com sucesso");
          } catch (err) {
            console.error("Erro ao desconectar peer:", err);
          }
        }
      };

      const setupPeer = () => {
        if (!peerId) return;

        console.log("Configurando distribuidor com ID:", peerId);
        setConnectionStatus('conectando');
        
        if (peerInstance.current) {
          try {
            peerInstance.current.destroy();
          } catch (err) {
            console.error("Erro ao destruir instância anterior:", err);
          }
        }
        
        const peer = new Peer(peerId, {
          host: '0.peerjs.com',
          port: 443,
          secure: true,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          },
          debug: 2
        });

        peer.on('open', (id) => {
          console.log("Distribuidor conectado com ID:", id);
          setConnectionStatus('conectado');
        });

        peer.on('connection', (conn) => {
          console.log("Nova conexão recebida de:", conn.peer);
          setupConnection(conn);
        });

        peer.on('call', (call) => {
          // Determinar o tipo de chamada pelos metadados
          const callType = call.metadata && call.metadata.type === 'voice' ? 'voice' : 'video';
          
          console.log(`Chamada de ${callType} recebida de ${call.peer}`);
          
          if (callType === 'voice') {
            setStats(prev => ({
              ...prev,
              voiceCallsReceived: prev.voiceCallsReceived + 1
            }));
          } else {
            setStats(prev => ({
              ...prev,
              callsReceived: prev.callsReceived + 1
            }));
          }

          // Criar um stream vazio apenas para responder à chamada, sem enviar mídia do distribuidor
          const emptyStream = new MediaStream();
          call.answer(emptyStream);

          call.on('stream', (remoteStream) => {
            console.log(`Recebido stream de ${call.peer} (${callType}) com ${remoteStream.getAudioTracks().length} trilhas de áudio e ${remoteStream.getVideoTracks().length} trilhas de vídeo`);
            
            // Verificar se temos tracks disponíveis
            if ((callType === 'voice' && remoteStream.getAudioTracks().length === 0) &&
                (callType === 'video' && remoteStream.getTracks().length === 0)) {
              console.error(`Não há trilhas disponíveis no stream recebido de ${call.peer}`);
              return;
            }
            
            // Verificar se já existe uma entrada para esse peer e tipo de chamada
            let existingCallData;
            if (activeCallsRef.current.has(call.peer)) {
              const calls = activeCallsRef.current.get(call.peer);
              existingCallData = calls.find(c => c.type === callType);
            }
            
            if (existingCallData) {
              // Atualizar o stream na chamada existente
              console.log(`Atualizando stream existente para ${call.peer} (${callType})`);
              existingCallData.stream = remoteStream;
              
              // Atualizar todas as redistribuições existentes com o novo stream
              existingCallData.redistributedCalls.forEach((redistCall, peerId) => {
                try {
                  // Criar um novo stream com as trilhas do stream remoto recebido
                  const newRedistributedStream = new MediaStream();
                  remoteStream.getTracks().forEach(track => {
                    newRedistributedStream.addTrack(track);
                  });
                  
                  // Fechar a chamada antiga e criar uma nova com o stream atualizado
                  redistCall.close();
                  
                  // Criar nova chamada com o stream atualizado
                  const newRedistCall = peerInstance.current.call(peerId, newRedistributedStream, {
                    metadata: { type: callType }
                  });
                  
                  existingCallData.redistributedCalls.set(peerId, newRedistCall);
                  
                  newRedistCall.on('stream', (clientRemoteStream) => {
                    console.log(`Recebido stream de volta de ${peerId} durante redistribuição atualizada de ${callType}`);
                  });
                  
                  newRedistCall.on('close', () => {
                    console.log(`Chamada de ${callType} redistribuída para ${peerId} encerrada`);
                    existingCallData.redistributedCalls.delete(peerId);
                  });
                  
                  newRedistCall.on('error', (err) => {
                    console.error(`Erro na chamada de ${callType} redistribuída para ${peerId}:`, err);
                  });
                  
                } catch (err) {
                  console.error(`Erro ao atualizar redistribuição para ${peerId}:`, err);
                }
              });
              
            } else {
              // Criar uma nova entrada para esse peer e tipo de chamada
              const callData = { 
                call, 
                stream: remoteStream, 
                redistributedCalls: new Map(),
                type: callType
              };
              
              // Adicionar a chamada ao activeCallsRef
              if (!activeCallsRef.current.has(call.peer)) {
                activeCallsRef.current.set(call.peer, []);
              }
              activeCallsRef.current.get(call.peer).push(callData);

              // Redistribuir o stream para outros clientes conectados
              activeConnectionsRef.current.forEach((conn, peerId) => {
                if (peerId !== call.peer) {
                  try {
                    console.log(`Iniciando chamada de ${callType} para ${peerId}`);
                    
                    // Clone o stream original para redistribuir
                    const redistributedStream = new MediaStream();
                    
                    // Copiar as trilhas relevantes dependendo do tipo de chamada
                    remoteStream.getTracks().forEach(track => {
                      redistributedStream.addTrack(track);
                    });

                    // Criar uma nova chamada para cada cliente conectado
                    const redistCall = peerInstance.current.call(peerId, redistributedStream, {
                      metadata: { type: callType }
                    });
                    
                    callData.redistributedCalls.set(peerId, redistCall);
                    
                    if (callType === 'voice') {
                      setStats(prev => ({
                        ...prev,
                        voiceCallsDistributed: prev.voiceCallsDistributed + 1
                      }));
                    } else {
                      setStats(prev => ({
                        ...prev,
                        callsDistributed: prev.callsDistributed + 1
                      }));
                    }

                    redistCall.on('stream', (clientRemoteStream) => {
                      console.log(`Recebido stream de volta de ${peerId} durante redistribuição de ${callType}`);
                    });

                    redistCall.on('close', () => {
                      console.log(`Chamada de ${callType} redistribuída para ${peerId} encerrada`);
                      callData.redistributedCalls.delete(peerId);
                    });

                    redistCall.on('error', (err) => {
                      console.error(`Erro na chamada de ${callType} redistribuída para ${peerId}:`, err);
                    });
                  } catch (err) {
                    console.error(`Erro ao redistribuir chamada de ${callType} para ${peerId}:`, err);
                  }
                }
              });
            }
          });

          call.on('close', () => {
            console.log(`Chamada de ${callType} com ${call.peer} encerrada`);
            if (activeCallsRef.current.has(call.peer)) {
              const calls = activeCallsRef.current.get(call.peer);
              const callIndex = calls.findIndex(c => c.call === call);
              if (callIndex !== -1) {
                const callData = calls[callIndex];
                callData.redistributedCalls.forEach(redistCall => {
                  try {
                    redistCall.close();
                  } catch (e) {
                    console.error(`Erro ao encerrar chamada de ${callType} redistribuída:`, e);
                  }
                });
                // Não remover a entrada completamente para permitir que futuras chamadas
                // do mesmo peer sejam tratadas corretamente
                // calls.splice(callIndex, 1);
                // if (calls.length === 0) {
                //   activeCallsRef.current.delete(call.peer);
                // }
              }
            }
          });

          call.on('error', (err) => {
            console.error(`Erro na chamada de ${callType} com ${call.peer}:`, err);
          });
        });

        peer.on('error', (err) => {
          console.error("Erro no peer:", err);
          setConnectionStatus('erro');
        });

        peer.on('disconnected', () => {
          console.log("Peer desconectado");
          setConnectionStatus('desconectado');
        });

        peerInstance.current = peer;
      };

      useEffect(() => {
        if (connectionStatus !== 'conectado' && connectionStatus !== 'conectando') return;
        
        const checkConnectionInterval = setInterval(() => {
          if (peerInstance.current && peerInstance.current.disconnected) {
            console.log("Tentando reconectar...");
            try {
              peerInstance.current.reconnect();
            } catch (e) {
              console.error("Falha na reconexão, recriando peer:", e);
              setupPeer();
            }
          }
        }, 30000);

        return () => {
          clearInterval(checkConnectionInterval);
        };
      }, [connectionStatus]);

      const handleIdChange = (newId) => {
        disconnectPeer();
      };

      const handleIncomingData = (data, sourceConn) => {
        console.log(`Recebendo dados de ${sourceConn.peer}:`, data);
        
        setStats(prev => ({
          ...prev,
          messagesReceived: prev.messagesReceived + 1
        }));

        if (data.type === 'message') {
          const newMessage = {
            id: Date.now() + Math.random().toString(36).substring(7),
            text: data.text,
            sender: data.senderName || sourceConn.peer,
            timestamp: new Date().toISOString(),
            source: sourceConn.peer
          };
          
          setMessages(prev => [...prev, newMessage]);
          
          distributeMessage(data, sourceConn.peer);
        }
        else if (data.type === 'file-start' || data.type === 'file-chunk') {
          console.log("Arquivo recebido, redistribuindo...");
          distributeMessage(data, sourceConn.peer);
        }
        else if (data.type === 'audio-start' || data.type === 'audio-chunk') {
          console.log("Áudio recebido, redistribuindo...");
          distributeMessage(data, sourceConn.peer);
        }
      };

      const distributeMessage = (data, sourceId) => {
        let distributionCount = 0;
        
        activeConnectionsRef.current.forEach((conn, peerId) => {
          if (peerId !== sourceId) {
            try {
              console.log(`Distribuindo mensagem para ${peerId}`);
              conn.send(data);
              distributionCount++;
            } catch (err) {
              console.error(`Erro ao enviar para ${peerId}:`, err);
            }
          }
        });
        
        setStats(prev => ({
          ...prev,
          messagesDistributed: prev.messagesDistributed + distributionCount
        }));
        
        console.log(`Mensagem distribuída para ${distributionCount} conexões`);
      };

      const setupConnection = (conn) => {
        conn.on('open', () => {
          console.log(`Conexão estabelecida com ${conn.peer}`);
          
          activeConnectionsRef.current.set(conn.peer, conn);
          
          setConnections(Array.from(activeConnectionsRef.current.keys()));
          
          setStats(prev => ({
            ...prev,
            activeConnections: activeConnectionsRef.current.size
          }));
        });

        conn.on('data', (data) => {
          handleIncomingData(data, conn);
        });

        conn.on('close', () => {
          console.log(`Conexão fechada com ${conn.peer}`);
          
          if (activeCallsRef.current.has(conn.peer)) {
            activeCallsRef.current.get(conn.peer).forEach(callData => {
              callData.call.close();
              callData.redistributedCalls.forEach(redistCall => {
                try {
                  redistCall.close();
                } catch (e) {
                  console.error(`Erro ao encerrar chamada de ${callData.type} redistribuída:`, e);
                }
              });
            });
            activeCallsRef.current.delete(conn.peer);
          }
          
          activeConnectionsRef.current.delete(conn.peer);
          
          setConnections(Array.from(activeConnectionsRef.current.keys()));
          
          setStats(prev => ({
            ...prev,
            activeConnections: activeConnectionsRef.current.size
          }));
        });

        conn.on('error', (err) => {
          console.error(`Erro na conexão com ${conn.peer}:`, err);
        });
      };

      return (
        <div>
          <h1>P2P Message Distributor</h1>
          <p>The ID consists of 6 alphanumeric characters.</p>
          <p>More specifically:</p>
          <p>Letters: A to Z (uppercase and lowercase)</p>
          <p>Numbers: 0 to 9</p>    
          <div className="peer-id-container">
            <div>
              <span 
                className={`status-indicator status-${
                  connectionStatus === 'conectado' ? 'online' : 
                  connectionStatus === 'conectando' ? 'connecting' : 'offline'
                }`}
              ></span>
              Status: {connectionStatus}
              <button onClick={toggleConnection}>
                {connectionStatus === 'conectado' || connectionStatus === 'conectando' ? 'Desconectar' : 'Conectar'}
              </button>
            </div>
          </div>
          
          <IdBackupTools 
            peerId={peerId} 
            setPeerId={setPeerId} 
            onSaveId={handleIdChange} 
            isConnected={connectionStatus === 'conectado' || connectionStatus === 'conectando'}
          />
          
          <div className="distribution-stats">
            <h3>Distribution Statistics</h3>
            <p>Messages received: {stats.messagesReceived}</p>
            <p>Distributed messages: {stats.messagesDistributed}</p>
            <p>Video calls received: {stats.callsReceived}</p>
            <p>Distributed video calls: {stats.callsDistributed}</p>
            <p>Voice calls received: {stats.voiceCallsReceived}</p>
            <p>Distributed voice calls: {stats.voiceCallsDistributed}</p>
            <p>Active connections: {stats.activeConnections}</p>
          </div>
          
          <div className="connected-peers">
            <h3>Active Connections ({connections.length})</h3>
            {connections.length === 0 ? (
              <p>No active connections</p>
            ) : (
              <div>
                {connections.map((peerId, index) => (
                 <div key={index} className="peer-item">
                    <span className="status-indicator status-online"></span>
                    {peerId}
                    {activeCallsRef.current.has(peerId) && activeCallsRef.current.get(peerId).map((callData, callIndex) => (
                      <span key={callIndex} className="call-type-badge">
                        {callData.type === 'voice' ? 'Voice' : 'Video'}
                      </span>
                    ))}
                  </div>
                ))}
              </div>
            )}
          </div>

          <div style={{ marginTop: '20px' }}>
            <h3>Messages</h3>
            <div style={{ maxHeight: '300px', overflowY: 'auto', border: '1px solid #ddd', padding: '10px' }}>
              {messages.length === 0 ? (
                <p>Nenhuma mensagem recebida</p>
              ) : (
                <div>
                  {messages.map((msg, index) => (
                    <div key={index} className={`message other`}>
                      <strong>{msg.sender || msg.source}:</strong> {msg.text}
                      <div className="message-source">
                        Origem: {msg.source} | {new Date(msg.timestamp).toLocaleTimeString()}
                      </div>
                    </div>
                  ))}
                  <div ref={messagesEndRef} />
                </div>
              )}
            </div>
          </div>

          <CallDebugInfo activeCalls={Object.fromEntries(activeCallsRef.current)} />
        </div>
      );
    };

    ReactDOM.render(<DistributorApp />, document.getElementById('root'));
  </script>
</head>
<body>
  <div id="root"></div>
<script>



// Script automatizado para testar chamadas de voz via distribuidor P2P

(async () => {
  const log = (msg) => console.log(`[Teste] ${msg}`);

  const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  log("Iniciando testes automatizados de chamada P2P...");

  if (!window.Peer) {
    log("PeerJS não carregado. Testes abortados.");
    return;
  }

  // IDs fixos para testes
  const CLIENT_A_ID = "TESTA1";
  const CLIENT_B_ID = "TESTB2";

  // Criação de dois peers (cliente A e B)
  const clientA = new Peer(CLIENT_A_ID, { host: '0.peerjs.com', port: 443, secure: true });
  const clientB = new Peer(CLIENT_B_ID, { host: '0.peerjs.com', port: 443, secure: true });

  let audioStreamA = null;
  let audioStreamB = null;

  clientA.on('open', async () => {
    log("Cliente A conectado: " + CLIENT_A_ID);
    try {
      audioStreamA = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      log("Erro ao acessar microfone no cliente A: " + err);
    }
  });

  clientB.on('open', async () => {
    log("Cliente B conectado: " + CLIENT_B_ID);
    try {
      audioStreamB = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      log("Erro ao acessar microfone no cliente B: " + err);
    }

    await wait(2000); // aguarda A estar pronto
    if (audioStreamA) {
      const call = clientA.call(CLIENT_B_ID, audioStreamA, { metadata: { type: 'voice' } });
      call.on('stream', (remoteStream) => {
        log("Cliente A recebeu stream do Cliente B");
        const audio = new Audio();
        audio.srcObject = remoteStream;
        audio.play();
      });
    }
  });

  clientB.on('call', (call) => {
    if (audioStreamB) {
      call.answer(audioStreamB);
      call.on('stream', (remoteStream) => {
        log("Cliente B recebeu stream do Cliente A");
        const audio = new Audio();
        audio.srcObject = remoteStream;
        audio.play();
      });
    }reader.onerror = (err) => {
        console.error(`App: Error reading ${typePrefix} blob:`, err);
        alert(`Erro ao ler dados: ${err.message}`);
        setMessages(prev => prev.map(msg => msg[idKey] === id ? { ...msg, sending: false, progress: -1 } : msg));
      };
      readChunk();
    };

    /*
      TÍTULO: Gerenciamento de Arquivos
      
      DESCRIÇÃO DETALHADA:
      As funções handleFileChange e handleAudioRecording implementam a interface para envio
      de arquivos e gravações de áudio no chat, coordenando as validações necessárias e
      iniciando o processo de transferência de dados em chunks.
      
      Aspectos principais e funcionamento:
      
      1. Verificações Preliminares: Ambas as funções realizam verificações essenciais antes
         de iniciar a transferência, como:
         - Confirmar se o usuário definiu seu nome
         - Verificar se há um contato selecionado para envio
         - Validar se existe uma conexão ativa com o contato
      
      2. Seleção de Arquivos: A função handleFileChange é acionada quando o usuário seleciona
         um arquivo através do input oculto, obtém o arquivo selecionado e o passa para o
         sistema de transferência.
      
      3. Processamento de Áudio: A função handleAudioRecording recebe um blob de áudio do
         componente VoiceRecorder e o encaminha para o sistema de transferência, permitindo
         o envio de mensagens de voz.
      
      4. Integração com UI: Ambas as funções interagem com elementos da UI, como alertas para
         feedback ao usuário e manipulação de inputs.
      
      5. Reset após Envio: handleFileChange limpa o campo de arquivo após o envio para permitir
         a seleção do mesmo arquivo novamente, se necessário.
      
      Estas funções demonstram uma boa separação de responsabilidades: elas não implementam
      diretamente a lógica de transferência, mas realizam validações contextuais e conectam
      a interface do usuário ao subsistema de transmissão de dados.
    */
    
    const handleFileChange = (e) => {
      if (!userName.trim()) {
        alert('Defina seu nome.');
        setEditingName(true);
        return;
      }
      if (!selectedContact) {
        alert('Selecione um contato.');
        return;
      }
      const file = e.target.files[0];
      if (!file) return;
      const conn = connections.find(c => c.peer === selectedContact);
      if (!conn || !conn.open) {
        alert(`Contato ${getContactName(selectedContact)} offline.`);
        return;
      }

      sendChunkedData(conn, 'fileId', file, 'file', { fileName: file.name });
      fileInputRef.current.value = '';
    };

    const handleAudioRecording = (audioBlob, targetContact) => {
      if (!userName.trim()) {
        alert('Defina seu nome.');
        setEditingName(true);
        return;
      }
      if (!targetContact) {
        alert('Selecione um contato.');
        return;
      }
      const conn = connections.find(c => c.peer === targetContact);
      if (!conn || !conn.open) {
        alert(`Contato ${getContactName(targetContact)} offline.`);
        return;
      }

      sendChunkedData(conn, 'audioId', audioBlob, 'audio', {});
    };
    
    //FIM
    
    /*
      TÍTULO: Sistema de Chamadas de Voz
      
      DESCRIÇÃO DETALHADA:
      A função startVoiceCall implementa o sistema para iniciar chamadas de voz entre usuários,
      utilizando WebRTC através da biblioteca PeerJS. Esta funcionalidade possibilita
      comunicação por voz em tempo real, sem a necessidade de servidores intermediários.
      
      Principais aspectos e funcionamento:
      
      1. Verificações Iniciais: Realiza validações importantes antes de iniciar a chamada:
         - Verifica se o PeerJS está inicializado
         - Confirma se existe um contato selecionado para a chamada
         - Evita iniciar chamadas duplicadas com o mesmo contato
         - Valida se existe uma conexão ativa com o contato
      
      2. Acesso ao Microfone: Solicita permissão para acessar o microfone do usuário através
         da API MediaDevices, criando um fluxo de áudio (stream) para transmissão.
      
      3. Armazenamento de Streams: Registra o stream local em um Map para facilitar a limpeza
         posterior, quando a chamada for encerrada.
      
      4. Estabelecimento da Chamada: Utiliza o método call do PeerJS para criar uma conexão
         de mídia com o contato escolhido, passando o stream de áudio e metadados (tipo de chamada).
      
      5. Gerenciamento de Estado da Chamada: Atualiza o estado activeCalls para refletir a
         nova chamada, permitindo que a UI exiba informações adequadas.
      
      6. Recepção do Stream Remoto: Configura um handler para o evento 'stream', que é disparado
         quando o fluxo de áudio do contato é recebido, adicionando-o ao estado remoteStreams.
      
      7. Manipulação de Eventos do Ciclo de Vida: Define handlers para os eventos 'close' e 'error',
         garantindo que os recursos sejam liberados adequadamente ao final da chamada.
      
      8. Tratamento de Erros: Implementa captura e tratamento de erros durante todo o processo
         de chamada, desde o acesso ao microfone até problemas na conexão WebRTC.
      
      Esta implementação oferece uma experiência de chamada de voz robusta, gerenciando
      corretamente o ciclo de vida dos streams de mídia e proporcionando feedback adequado
      ao usuário em caso de erros.
    */
    
    const startVoiceCall = async (peerIdToCall) => {
      if (!peerInstance.current) {
        alert('Peer não inicializado');
        return;
      }
      if (!peerIdToCall) {
        alert('Selecione um contato.');
        return;
      }
      if (activeCalls.some(c => c.peerId === peerIdToCall && c.type === 'voice')) return;
      const conn = connections.find(c => c.peer === peerIdToCall);
      if (!conn || !conn.open) {
        alert(`Contato ${getContactName(peerIdToCall)} offline.`);
        return;
      }

      try {
        console.log("App: Starting voice call with:", peerIdToCall);
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        if (!stream) return;

        localStreamsRef.current.set(peerIdToCall + '_voice', stream);
        const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'voice' } });

        setActiveCalls(prev => [
          ...prev,
          {
            peerId: peerIdToCall,
            call,
            localStream: stream,
            type: 'voice',
            direction: 'outgoing',
            isTemporaryStream: false
          }
        ]);

        call.on('stream', (remoteStream) => {
          console.log(`App: Received remote audio stream from:`, peerIdToCall);
          setRemoteStreams(prev => [
            ...prev.filter(s => !(s.peerId === peerIdToCall && s.type === 'voice')),
            { peerId: peerIdToCall, stream: remoteStream, type: 'voice' }
          ]);
        });
        call.on('close', () => {
          console.log("App: Voice call closed with:", peerIdToCall);
          endCall(peerIdToCall, 'voice');
        });
        call.on('error', (err) => {
          console.error('App: Error in voice call:', err);
          alert('Erro chamada de voz: ' + err.message);
          endCall(peerIdToCall, 'voice');
        });
      } catch (err) {
        console.error('App: Error starting voice call:', err);
        alert('Erro ao acessar microfone: ' + err.message);
      }
    };
    
    //FIM
    
    /*
      TÍTULO: Sistema de Chamadas de Vídeo
      
      DESCRIÇÃO DETALHADA:
      A função toggleVideoCall implementa um sistema completo para gerenciar chamadas de vídeo,
      permitindo tanto iniciar quanto encerrar videoconferências com outros usuários.
      Este componente é a base da funcionalidade de comunicação visual em tempo real da aplicação.
      
      Principais características e funcionamento:
      
      1. Toggle Inteligente: A função atua como uma chave que alterna entre ligar e desligar
         a câmera, baseando-se no estado atual da chamada com determinado contato.
      
      2. Desativação do Vídeo: Quando o usuário já está enviando vídeo para um contato,
         a função:
         - Para todas as tracks de mídia do stream local
         - Remove o stream do registro interno (localStreamsRef)
         - Atualiza o estado da chamada para refletir a remoção do stream local
         - Esconde o preview de vídeo local se não houver mais streams ativos
      
      3. Ativação do Vídeo: Quando o usuário deseja iniciar/retomar o envio de vídeo:
         - Solicita permissão para acessar câmera e microfone via MediaDevices API
         - Registra o stream obtido para controle posterior
         - Exibe o preview do vídeo local na interface
      
      4. Lógica de Chamadas Existentes: Implementa um tratamento especial para casos onde
         já existe uma chamada estabelecida com o contato:
         - Apenas adiciona um stream local à chamada existente
         - Inicia uma nova chamada unidirecional para enviar o vídeo
         - Mantém a chamada bidirecional original intacta
      
      5. Novas Chamadas: Para contatos sem chamada ativa, cria uma nova chamada completa:
         - Estabelece conexão WebRTC via PeerJS
         - Configura handlers para todos os eventos importantes (stream, close, error)
         - Atualiza os estados para refletir a nova chamada na interface
      
      6. Tratamento de Erros: Implementa captura e tratamento robusto de erros para todas
         as operações, desde acesso a dispositivos até falhas na conexão WebRTC.
      
      Este sistema de videochamadas demonstra uma arquitetura bem projetada para lidar
      com a complexidade do WebRTC, gerenciando adequadamente diferentes estados de chamada
      e proporcionando uma experiência fluida ao usuário.
    */
    
    const toggleVideoCall = async (peerIdToCall) => {
      if (!peerInstance.current) {
        alert('Peer não inicializado');
        return;
      }
      if (!peerIdToCall) {
        alert('Selecione um contato.');
        return;
      }

      const existingCall = activeCalls.find(c => c.peerId === peerIdToCall && c.type === 'video');
      const isSendingVideo = existingCall && existingCall.localStream;
      const conn = connections.find(c => c.peer === peerIdToCall);

      if (isSendingVideo) {
        // Usuário já está enviando vídeo - vamos desligar a câmera
        console.log("App: Stopping local video stream for:", peerIdToCall);
        if (existingCall && existingCall.localStream) {
          existingCall.localStream.getTracks().forEach(track => track.stop());
          localStreamsRef.current.delete(peerIdToCall + '_video');
        }
        
        // Não feche a chamada completamente, apenas atualize o estado para remover o stream local
        setActiveCalls(prev => prev.map(c => {
          if (c.peerId === peerIdToCall && c.type === 'video') {
            return { ...c, localStream: null };
          }
          return c;
        }));
        
        if (localStreamsRef.current.size === 0) {
          setIsLocalVideoVisible(false);
          if (localVideoRef.current) localVideoRef.current.srcObject = null;
        }
        
      } else {
        // Usuário quer ligar a câmera
        if (!conn || !conn.open) {
          alert(`Contato ${getContactName(peerIdToCall)} offline.`);
          return;
        }

        try {
          console.log("App: Getting video stream for:", peerIdToCall);
          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          if (!stream) return;

          localStreamsRef.current.set(peerIdToCall + '_video', stream);
          setIsLocalVideoVisible(true);
          if (localVideoRef.current) localVideoRef.current.srcObject = stream;

          if (existingCall) {
            // Se já temos uma chamada existente, adicione o stream local a ela
            console.log("App: Adding local stream to existing call with:", peerIdToCall);
            
            // Atualize o estado da chamada com o novo stream local
            setActiveCalls(prev => prev.map(c => {
              if (c.peerId === peerIdToCall && c.type === 'video') {
                return { ...c, localStream: stream };
              }
              return c;
            }));
            
            // Inicie uma nova chamada para enviar seu vídeo
            const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'video' } });
            
            call.on('stream', (remoteStream) => {
              console.log(`App: Received remote video stream response from:`, peerIdToCall);
            });
            
            call.on('close', () => {
              console.log("App: Outgoing video stream call closed with:", peerIdToCall);
            });
            
            call.on('error', (err) => {
              console.error('App: Error in outgoing video stream call:', err);
            });
            
          } else {
            // Se não há chamada existente, inicie uma nova
            console.log("App: Starting new video call with:", peerIdToCall);
            const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'video' } });
            
            setActiveCalls(prev => [
              ...prev.filter(c => !(c.peerId === peerIdToCall && c.type === 'video')),
              {
                peerId: peerIdToCall,
                call,
                localStream: stream,
                type: 'video',
                direction: 'outgoing',
                isTemporaryStream: false
              }
            ]);

            call.on('stream', (remoteStream) => {
              console.log(`App: Received remote video stream from:`, peerIdToCall);
              setRemoteStreams(prev => [
                ...prev.filter(s => !(s.peerId === peerIdToCall && s.type === 'video')),
                { peerId: peerIdToCall, stream: remoteStream, type: 'video' }
              ]);
            });

            call.on('close', () => {
              console.log("App: Video call closed with:", peerIdToCall);
              endCall(peerIdToCall, 'video');
            });

            call.on('error', (err) => {
              console.error('App: Error in video call:', err);
              alert('Erro chamada de vídeo: ' + err.message);
              endCall(peerIdToCall, 'video');
            });
          }
        } catch (err) {
          console.error('App: Error starting video call:', err);
          alert('Erro ao acessar câmera/microfone: ' + err.message);
        }
      }
    };
    
    //FIM
    
    /*
      TÍTULO: Sistema de Encerramento de Chamadas
      
      DESCRIÇÃO DETALHADA:
      A função endCall implementa o mecanismo para finalizar chamadas de voz e vídeo,
      garantindo que todos os recursos associados sejam corretamente liberados e que
      a interface reflita o novo estado da aplicação.
      
      Principais funcionalidades e funcionamento:
      
      1. Encerramento da Conexão WebRTC: Fecha a conexão PeerJS associada à chamada,
         notificando o outro peer sobre o encerramento e interrompendo a transmissão
         de mídia.
      
      2. Liberação de Recursos de Mídia: Interrompe todas as tracks de mídia ativas
         (áudio/vídeo) associadas à chamada, garantindo que os dispositivos (microfone,
         câmera) sejam liberados corretamente.
      
      3. Gerenciamento de Referências Internas: Remove o stream do registro interno
         (localStreamsRef) através da função auxiliar stopAndRemoveLocalStream.
      
      4. Atualização de Estado: Remove a chamada encerrada dos estados activeCalls
         e remoteStreams, garantindo que a interface seja atualizada corretamente.
      
      5. Gerenciamento do Vídeo Local: Implementa lógica para:
         - Esconder o preview de vídeo local quando não há mais chamadas ativas
         - Alternar o preview para outro stream ativo se a chamada atual era a que
           estava sendo visualizada
      
      6. Detecção de Streams Ativos: Verifica se ainda existem streams de vídeo ativos
         após o encerramento da chamada e atualiza a interface de acordo.
      
      Esta função é essencial para garantir uma experiência de usuário limpa, sem
      vazamentos de memória ou consumo desnecessário de recursos do dispositivo,
      um aspecto crítico em aplicações que utilizam recursos de mídia.
    */
    
    const endCall = (peerIdToEnd, callType) => {
      console.log(`App: Ending ${callType} call with:`, peerIdToEnd);
      const callData = activeCalls.find(c => c.peerId === peerIdToEnd && c.type === callType);

      if (callData) {
        if (callData.call) {
          callData.call.close();
        }
        if (callData.localStream) {
          callData.localStream.getTracks().forEach(track => track.stop());
          console.log(`App: Stopped local stream tracks for ${callType} call with ${peerIdToEnd}`);
          stopAndRemoveLocalStream(peerIdToEnd + '_' + callType);
        }
      }

      setActiveCalls(prev => prev.filter(c => !(c.peerId === peerIdToEnd && c.type === callType)));
      setRemoteStreams(prev => prev.filter(s => !(s.peerId === peerIdToEnd && s.type === callType)));

      const anyLocalVideoActive = Array.from(localStreamsRef.current.values()).some(
        stream => stream.getVideoTracks().some(t => t.readyState === 'live')
      );
      if (!anyLocalVideoActive) {
        setIsLocalVideoVisible(false);
        if (localVideoRef.current) localVideoRef.current.srcObject = null;
      } else if (
        isLocalVideoVisible &&
        (!localVideoRef.current?.srcObject?.active || localVideoRef.current?.srcObject === callData?.localStream)
      ) {
        const firstActiveStream = localStreamsRef.current.values().next().value;
        if (localVideoRef.current && firstActiveStream) {
          localVideoRef.current.srcObject = firstActiveStream;
        }
      }
    };
    
    //FIM
    
    /*
      TÍTULO: Componentes de Interface de Usuário Auxiliares
      
      DESCRIÇÃO DETALHADA:
      Esta seção implementa componentes e funções auxiliares para a interface do usuário
      que melhoram a experiência e facilitam a interação com a aplicação.
      
      Principais componentes e funcionalidades:
      
      1. Sistema de Emojis (populateEmojiPanel):
         - Cria um painel de seleção de emojis para inserção rápida em mensagens de texto
         - Organiza uma grande coleção de emojis em uma grade navegável
         - Implementa a lógica para inserir o emoji selecionado na mensagem atual
      
      2. Formulário de Nome (renderNameForm):
         - Fornece uma interface para o usuário definir ou editar seu nome de exibição
         - Inclui validação básica (botão desabilitado quando o campo está vazio)
         - Salva o nome no localStorage para persistência entre sessões
      
      3. Tratamento de Erros na Interface:
         - Implementa uma visualização específica para o caso de ocorrer um erro crítico
         - Exibe mensagem amigável com opção para recarregar a aplicação
      
      4. Renderização Condicional Principal:
         - Alterna entre a tela de chat principal e a tela de gerenciamento de contatos
         - Organiza os elementos da interface principal em seções lógicas (cabeçalho,
           informações do usuário, container de vídeo, chamadas ativas, etc.)
      
      5. Integração dos Componentes:
         - Conecta todos os componentes e subcomponentes da aplicação
         - Passa as props necessárias para o funcionamento adequado de cada parte
      
      Este conjunto de componentes de UI demonstra uma abordagem modular e bem estruturada
      para a construção da interface, facilitando a manutenção e expansão futura da aplicação.
    */
    
    const populateEmojiPanel = () => {
      const emojis = [
        "😀","😁","😂","🤣","😃","😄","😅","😆","😉","😊",
        "😋","😎","😍","😘","🥰","😗","😙","😚","🙂","🤗",
        "🤩","🤔","🤨","😐","😑","😶","🙄","😏","😣","😥",
        "😮","🤐","😴","😪","😵","😤","😭","😡","🤯","🥵",
        "👍","👎","👌","✌️","🤞","👋","🤚","🖐️","👏","🙌",
        "👐","🤲","🙏","💪","🦵","🦶","👂","👃","🧠","🫀",
        "👀","👁️","🧑‍🦰","🧑‍🦱","🧑‍🦳","🧑‍🦲","👶","🧒","👦","👧",
        "🧑","👱‍♂️","👱‍♀️","🧔","👨‍🦰","👩‍🦰","👨‍🦱","👩‍🦱","👨‍🦳","👩‍🦳",
        "👨‍🦲","👩‍🦲","👩","👨","🧓","👴","👵","🙍‍♂️","🙍‍♀️","🙎‍♂️",
        "🙎‍♀️","🙅‍♂️","🙅‍♀️","🙆‍♂️","🙆‍♀️","💁‍♂️","💁‍♀️","🙋‍♂️","🙋‍♀️","🧏‍♂️",
        "🧏‍♀️","🙇‍♂️","🙇‍♀️","🤦‍♂️","🤦‍♀️","🤷‍♂️","🤷‍♀️","🧑‍⚕️","👨‍⚕️","👩‍⚕️",
        "🧑‍🎓","👨‍🎓","👩‍🎓","🧑‍🏫","👨‍🏫","👩‍🏫","🧑‍⚖️","👨‍⚖️","👩‍⚖️","🧑‍🌾",
        "👨‍🌾","👩‍🌾","🧑‍🍳","👨‍🍳","👩‍🍳","🧑‍🔧","👨‍🔧","👩‍🔧","🧑‍🏭","👨‍🏭",
        "👩‍🏭","🧑‍💼","👨‍💼","👩‍💼","🧑‍🔬","👨‍🔬","👩‍🔬","🧑‍💻","👨‍💻","👩‍💻",
        "🧑‍🎤","👨‍🎤","👩‍🎤","🧑‍🎨","👨‍🎨","👩‍🎨","🧑‍✈️","👨‍✈️","👩‍✈️","🧑‍🚀",
        "👨‍🚀","👩‍🚀","🧑‍🚒","👨‍🚒","👩‍🚒","👮‍♂️","👮‍♀️","🕵️‍♂️","🕵️‍♀️","💂‍♂️",
        "💂‍♀️","🥷","👷‍♂️","👷‍♀️","🤴","👸","👳‍♂️","👳‍♀️","👲","🧕",
        "🤵","👰","🤰","🤱","👩‍🍼","👨‍🍼","🧑‍🍼","🧙‍♂️","🧙‍♀️","🧚‍♂️",
        "🧚‍♀️","🧛‍♂️","🧛‍♀️","🧜‍♂️","🧜‍♀️","🧝‍♂️","🧝‍♀️","🧞‍♂️","🧞‍♀️","🧟‍♂️",
        "🧟‍♀️","💆‍♂️","💆‍♀️","💇‍♂️","💇‍♀️","🚶‍♂️","🚶‍♀️","🏃‍♂️","🏃‍♀️","💃",
        "🕺","🕴️","👯‍♂️","👯‍♀️","🧖‍♂️","🧖‍♀️","🧗‍♂️","🧗‍♀️","🏇","⛷️",
        "🏂","🏌️‍♂️","🏌️‍♀️","🏄‍♂️","🏄‍♀️","🚣‍♂️","🚣‍♀️","🏊‍♂️","🏊‍♀️","⛹️‍♂️",
        "⛹️‍♀️","🏋️‍♂️","🏋️‍♀️","🚴‍♂️","🚴‍♀️","🚵‍♂️","🚵‍♀️","🤸‍♂️","🤸‍♀️","🤼‍♂️",
        "🤼‍♀️","🤽‍♂️","🤽‍♀️","🤾‍♂️","🤾‍♀️","🤹‍♂️","🤹‍♀️","🧘‍♂️","🧘‍♀️","🛀"
      ];

      return (
        <div className="emoji-panel">
          <div className="emoji-panel-header">EMOJIS</div>
          <div className="emoji-panel-content">
            {emojis.map((emoji, index) => (
              <div key={index} className="emoji-item" onClick={() => setNewMessage(prev => prev + emoji)}>
                {emoji}
              </div>
            ))}
          </div>
          <div className="emoji-panel-footer">
            <div className="barra-rolagem-label"><br /></div>
          </div>
        </div>
      );
    };

    const renderNameForm = () => (
      <div className="user-name-form">
        <input
          type="text"
          value={userName}
          onChange={(e) => setUserName(e.target.value)}
          placeholder="Digite seu nome"
          required
        />
        <button onClick={saveUserName} disabled={!userName.trim()}>Salvar</button>
      </div>
    );

    if (error) {
      return (
        <div className="error-message">
          <h1>Erro na Aplicação</h1>
          <p>{error}</p>
          <button onClick={() => window.location.reload()}>Recarregar</button>
        </div>
      );
    }

    return (
      <div>
        {!showContacts ? (
          <div>
            <div className="app-header">
              <h1 className="app-title">PSA</h1>
              <div className="header-buttons">
                <button className="header-button" onClick={() => setShowContacts(true)} title="Ver Contatos">
                  <i className="fas fa-address-book"></i>
                </button>
              </div>
            </div>
            <div className="user-info-container">
              {editingName ? renderNameForm() : (
                <div style={{ display: 'flex', justifyContent: 'space-between', width: '100%' }}>
                  <span>Seu nome: <span className="username">{userName}</span></span>
                  <button onClick={() => setEditingName(true)} className="user-edit-button">Editar</button>
                </div>
              )}
            </div>
            <div className="peer-id-container">
              <span>Seu ID: {peerId}</span>
              <button onClick={() => navigator.
  });

  // Diagnóstico no console
  clientA.on('error', err => log("Erro Cliente A: " + err));
  clientB.on('error', err => log("Erro Cliente B: " + err));
})();



</script>
</body>
</html>
